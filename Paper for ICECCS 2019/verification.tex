\section{Verification}
In this section we show in Section~\ref{sec:functional} that the formal specification introduced in the previous section preserves a set of properties guaranteeing its functional correctness. As a security property, we also prove in Section~\ref{sec:securitymodel} and Section~\ref{sec:securityproof} that the specification preserves integrity of the memory structures.

\subsection{Functional correctness}\label{sec:functional}
We use preconditions $\&$ postconditions and invariants to depict and trace the executions of the specification for functional correctness purposes. We give preconditions and postconditions in the first place.

The following Lemma~\ref{pp1} gives such an implication: if any quad-tree Block in \emph{blo\_set} cannot satisfy the precondition: the level of its \emph{FREE} leaf nodes is less than or equal to the value of \emph{rlv}, then nothing is changed result from allocation failure.

\begin{lemma} [Allocation Failure]
\label{pp1}
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
\neg exists\_freelevel\ blo\_set\ rlv \longrightarrow fst\ (alloc\ blo\_set\ rlv) = blo\_set
\end{align*}
}
\vspace{-12pt}

Then Lemma~\ref{pp2} and~\ref{pp3} respectively describes a transition during a direct allocation process that the \emph{FREE} leaf node to be allocated no longer belongs to free sets and is a part of allocated sets. A direct allocation precess means that the existence of such a quad-tree Block in \emph{blo\_set}, the level of whose \emph{FREE} leaf nodes is less than or equal to the value of \emph{rlv}. In particular, the maximum level among these \emph{FREE} leaf nodes is equal to the value of \emph{rlv}, therefore the function picks up a \emph{FREE} leaf node in level \emph{rlv} to allocate.

\begin{lemma} [Freesets for Direct Allocation]
\label{pp2}
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
&(exists\_freelevel\ blo\_set\ rlv \wedge freesets\_maxlevel\ blo\_set\ rlv = rlv) \\ &\longrightarrow (\exists l.\ l \in freesets\ blo\_set \wedge l \notin freesets\ fst\ (alloc\ blo\_set\ rlv) \\
&\ \ \ \ \ \ \wedge freesets\ blo\_set = freesets\ fst\ (alloc\ blo\_set\ rlv) \cup \lbrace l \rbrace)
\end{align*}
}
\vspace{-12pt}

\begin{lemma} [Allocsets for Direct Allocation]
\label{pp3}
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
&(exists\_freelevel\ blo\_set\ rlv \wedge freesets\_maxlevel\ blo\_set\ rlv = rlv) \\ &\longrightarrow (\exists l.\ l \notin allocsets\ blo\_set\ \wedge l \in allocsets\ fst\ (alloc\ blo\_set\ rlv) \\
&\ \ \ \ \ \ \ \wedge allocsets\ fst\ (alloc\ blo\_set\ rlv) = allocsets\ blo\_set \cup \lbrace l \rbrace)
\end{align*}
}
\vspace{-12pt}

Next Lemma~\ref{pp4} introduces a transition during an indirect allocation process. The precondition preserves the existence of such a quad-tree Block in \emph{blo\_set}, the level of whose \emph{FREE} leaf nodes is less than or equal to the value of \emph{rlv}. However, the maximum level among these \emph{FREE} leaf nodes is less than the value of \emph{rlv}. With this precondition, \emph{split} operation is invoked to divide a bigger Leaf node into small Leaf nodes until a Leaf node that satisfies the request appears. Then postcondition guarantees that a new Leaf node is added into allocated set while it dose not belong to this set previously.

\begin{lemma} [Allocsets for Indirect Allocation]
\label{pp4}
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
&(exists\_freelevel\ blo\_set\ rlv \wedge freesets\_maxlevel\ blo\_set\ rlv \neq rlv) \\
&\longrightarrow (\exists l.\ l \notin allocsets\ blo\_set \wedge l \in allocsets\ fst\ (alloc\ blo\_set\ rlv) \\
&\wedge allocsets\ fst\ (alloc\ blo\_set\ rlv) = allocsets\ blo\_set \cup \lbrace l \rbrace)
\end{align*}
}
\vspace{-12pt}

The next two Lemma~\ref{pp5} and~\ref{pp6} guarantee nothing is changed during the deallocation failure processes. This consequence is result from the Leaf node to be released does not belong to any quad-tree Block, or the type of the Leaf node to be freed is \emph{FREE} already.

\begin{lemma} [Deallocation failure 1]
\label{pp5}
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
\nexists btree \in blo\_set.\ b \in set\ btree \longrightarrow fst\ (free\ blo\_set\ b) = blo\_set
\end{align*}
}
\vspace{-12pt}
	
\begin{lemma} [Deallocation failure 2]
\label{pp6}
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
&\exists btree \in blo\_set.\ b \in set\ btree \wedge fst\ b = FREE \\
&\longrightarrow fst\ (free\ blo\_set\ b) = blo\_set
\end{align*}
}
\vspace{-12pt}

The last Lemma~\ref{pp7} ensures a correct transition during a deallocation success process. It describes that the Leaf node which is to be released dose not belong to allocated set any more.

\begin{lemma} [Allocsets for Deallocation Success]
\label{pp7}
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
&\exists btree \in blo\_set.\ b \in set\ btree \wedge fst\ b \neq FREE \\ &\longrightarrow allocsets\ blo\_set = allocsets\ fst\ (free\ blo\_set\ b) \cup \lbrace b \rbrace
\end{align*}
}
\vspace{-12pt}

After giving these lemmas for preconditions $\&$ postconditions, we prove that our buddy allocation specification satisfies them so that it meets the functional expectations. The first theorem we prove as follows.

\begin{theorem}
The buddy allocation specification satisfies all the lemmas for preconditions $\&$ postconditions above.
\end{theorem}

Next, we introduce invariants to guarantee functional correctness of the specification from another point of view. Firstly, we ensure that the allocation operation picks out \emph{The Most Suitable Leaf Node} in Definition~\ref{mostsuitable}. Two properties are proved: the correctness of the mapping function from the size of requested memory block to the level of the quad-tree; the correctness of the quad-tree hierarchical structure. Here are these two properties.

Two lemmas ensure the correctness of Definition~\ref{mostsuitable}.

\begin{lemma} [Correctness of Function output\_level 1]
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
&\vert blo\_list \vert > 0 \wedge rsize \leq blo\_list\ !\ (\vert blo\_list \vert - 1) \\
&\longrightarrow output\_level\ blo\_list\ rsize = \vert blo\_list \vert - 1
\end{align*}
}
\vspace{-12pt}	

\begin{lemma} [Correctness of Function output\_level 2]
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
&\vert blo\_list \vert > 1 \wedge l < \vert blo\_list \vert - 1 \\
&\wedge rsize \leq blo\_list\ !\ l \wedge rsize > blo\_list\ !\ (l + 1) \\
&\longrightarrow output\_level\ blo\_list\ rsize = l
\end{align*}
}
\vspace{-12pt}

With these two lemmas, we make sure the correctness of the mapping function \emph{output\_level}. Then we introduce a lemma alone to prove the correctness of the hierarchical structure of a quad-tree. Function \textbf{root} checks whether the tree is a Root tree and function \textbf{child} gives us a set of all immediate child nodes of a Node tree.

\begin{lemma} [Hierarchical Structure of a Quad-tree]
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
&(root\ btree \longrightarrow get\_level\ btree = 0) \\
&\wedge (get\_level\ btree = l \wedge l \geq 0 \wedge chtree \in child\ btree \\
&\ \ \ \longrightarrow get\_level\ chtree = l + 1)
\end{align*}
}	
\vspace{-12pt}

Until now, we have already proved the correctness of the mapping function \emph{output\_level} and the hierarchical structure of a quad-tree. Then we can deduce the following theorem to guarantee the property of picking out \emph{The Most Suitable Leaf Node}.

\begin{theorem}
The buddy allocation specification picks out the most suitable Leaf node and allocate it on the correct level in a quad-tree.
\end{theorem}

The buddy allocation algorithms may reduce the fragmentation by invoking merge function during the process of deallocation. Whether this function is executed correctly can not be proved straightway. In order to prove this, we still consider the correctness of the structure to a quad-tree during allocation and deallocation processes. Considering the fact that there is not such a Node tree whose four immediate child nodes are all Leaf nodes and their types are \emph{FREE}, a definition is constructed as follows to check whether a quad-tree is such a Node tree. The function \textbf{leaf} is to check whether the tree is a Leaf node.

\begin{definition} [Four Free Leaves Belong to The Same Node]
\end{definition}
\vspace{-7pt}
{\footnotesize
\begin{align*}
is\_FFL\ btree \triangleq\ &\forall chtree \in child\ btree.\ leaf\ chtree \\
&\wedge fst\ chtree = FREE
\end{align*}
}
\vspace{-12pt}

Fig. \ref{fig2} can explain this definition well. As the first picture shows, the subtree in the lower left corner is such a Node tree because its four child nodes are all Leaf nodes and their types are \emph{FREE}. Therefore, merge function is necessary to handle this situation. The followings are lemmas that ensure the non-existence of such \emph{FFL} trees after allocation and deallocation operations if they guarantee non-existence of such \emph{FFL} trees in the assuming of implication expressions.

\begin{lemma} [Non-existence of FFL during Allocation]
\label{allocffl}
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
\forall b \in blo\_set.\ &\neg\ is\_FFL\ b \\
&\longrightarrow \forall b \in fst\ (alloc\ blo\_set\ rlv).\ \neg\ is\_FFL\ b
\end{align*}
}
\vspace{-12pt}

\begin{lemma} [Non-existence of FFL during Deallocation]
\label{deallocffl}
\end{lemma}
\vspace{-7pt}
{\footnotesize
\begin{align*}
\forall b \in blo\_set.\ &\neg\ is\_FFL\ b \\
&\longrightarrow \forall b \in fst\ (free\ blo\_set\ b).\ \neg\ is\_FFL\ b
\end{align*}
}
\vspace{-12pt}

We consider such a situation: operation system initialize the whole memory into a series of free blocks in different sizes, and these memory blocks are in the form of root nodes which are not split at the very beginning. This initialization state satisfies not-existence of \emph{FFL} trees. Then according to Lemma~\ref{allocffl} and~\ref{deallocffl}, any state after initialization satisfies non-existence of \emph{FFL} trees no matter operation system performs allocation or deallocation operations. Therefore, we can make sure the whole memory system preserves this property. We have this theorem as follows. Furthermore, it proves that the buddy allocation specification reduces the fragmentation by merge operation.

\begin{theorem}
The buddy allocation specification guarantees non-existence of FFL trees among all memory blocks.
\end{theorem}

In the end, we prove two significant properties: memory isolation and non-leakage. The first one is to ensure non-existence of the overlap in address spaces. The isolation makes sure that memory blocks of a domain can not be maliciously overwritten by others. Another property the non-leakage guarantees that available memory blocks (including occupied and free ones) are not getting less and less. In other words, it protects the integrity of address spaces.

Now we begin with the memory isolation. We provisionally use type \emph{ID} in basic type \emph{nat} to represent a contiguous address occupied by a memory block in Section~\ref{statedes}. To link \emph{ID} to a real address, two things have to be introduced and proved: 1. a mapping function between a \emph{ID} and a real address as well as its correctness; 2. the one-to-one uniqueness between a \emph{ID} and a real address. We leave this part to the further work for a more detailed specification proof, in other words the design level of the buddy allocation. In this paper, we are not going to introduce real addresses into this specification, and we consider the correctness of the mapping function and promise its the uniqueness. Therefore, with these assumptions, isolation of address spaces means that all \emph{IDs} which leaf nodes brings with are unique.

The following definition introduces a judgment whether two Leaf nodes have the same \emph{ID}. Function \textbf{ID} gives the \emph{ID} a Leaf node brings with.

\begin{definition} [Different IDs]
\vspace{-7pt}
\end{definition}
{\footnotesize
\begin{align*}
&is\_different\ blo\_set \triangleq \\
&\forall b \in blo\_set.\ \forall l \in set\ b.\ (\nexists l'.\ l' \in set\ (SOME\ b.\ b \in blo\_set) \\
&\ \ \ \ \wedge l' \ne l \wedge ID\ l' = ID\ l)
\end{align*}
}
\vspace{-12pt}

Below are two lemmas that ensure this property holds during the procedures of allocation and deallocation if it holds in the assuming of implication expressions.

\begin{lemma} [Different IDs during Allocation]
\vspace{-7pt}
\end{lemma}
{\footnotesize
\begin{align*}
is\_different\ blo\_set \longrightarrow is\_different\ fst\ (alloc\ blo\_set\ rlv)
\end{align*}
}
\vspace{-12pt}

\begin{lemma} [Different IDs during Deallocation]
\vspace{-7pt}
\end{lemma}
{\footnotesize
\begin{align*}
is\_different\ blo\_set \longrightarrow is\_different\ fst\ (free\ blo\_set\ b)
\end{align*}
}
\vspace{-12pt}

Let us go back to the initialization state. The whole memory is divided into a finite number of free root nodes. We can easily guarantee that all \emph{IDs} these root nodes bring with are unique and initialize the collection \emph{idset} with these used \emph{IDs}. Then according to the lemmas above, any state after initialization satisfies \emph{Different IDs} no matter operation system performs allocation or deallocation operations. As a result, we can guarantee the whole memory system preserve \emph{Different IDs}. We have this theorem as follows.

\begin{theorem}
The buddy allocation specification ensures all IDs of Leaf nodes are unique.
\end{theorem}

Finally, with the assumptions that the correctness of the mapping function between a \emph{ID} and a real address and promising its uniqueness, we prove the specification the property of the isolation of memory address spaces.

Next is for the non-leakage of memory blocks. We use a quad-tree structure and map all the blocks into the Leaf nodes of these trees, thence the non-leakage means that all the Leaf nodes (including occupied and free ones) are recorded in use. If we can infer a correct and certain relation between the number of Leaf nodes and Non-leaf nodes of a quad-tree, we can prove that all the Leaf nodes are in use and none of them is forgotten. To achieve this, the first step is to search and prove a certain relation between the numbers of Leaf nodes and Non-leaf nodes in a quad-tree. Through exploration, we have found and proved such a relation as follows. Functions \textbf{get\_leaf} and \textbf{get\_node} take a Block and return Leaf nodes set and Non-leaf nodes set respectively.

\begin{lemma} [Relation of a Quad-tree Nodes]
\vspace{-7pt}
\end{lemma}
{\footnotesize
\begin{align*}
Qtree\ b:\ size\ (get\_leaf\ b) = size\ (get\_node\ b) \times 3 + 1
\end{align*}
}
\vspace{-12pt}

After establishing this relation, we use the following two lemmas to guarantee all the quad-trees during execution procedures maintain this relation.

\begin{lemma} [Qtree during Allocation]
\vspace{-7pt}
\end{lemma}
{\footnotesize
\begin{align*}
\forall b \in blo\_set.\ Qtree\ b \longrightarrow \forall b \in fst\ (alloc\ blo\_set\ rlv).\ Qtree\ b
\end{align*}
}
\vspace{-12pt}

\begin{lemma} [Qtree during Deallocation]
\vspace{-7pt}
\end{lemma}
{\footnotesize
\begin{align*}
\forall b \in blo\_set.\ Qtree\ b \longrightarrow \forall b \in fst\ (free\ blo\_set\ b).\ Qtree\ b
\end{align*}
}
\vspace{-12pt}

In the end, we can prove that all quad-trees hold this relation between the number of Leaf nodes and Non-leaf nodes. The correct structure of a quad-tree means that all Leaf nodes (including occupied and free ones) are in use. We have this theorem as follows. Then considering the fact that all blocks are mapped into the Leaf nodes of these trees, we can ensure that the specification preserves memory non-leakage.

\begin{theorem}
The buddy allocation specification guarantees any Block is a Qtree.
\end{theorem}

To sum up, in this subsection we introduce preconditions $\&$ postconditions as well as significant invariants to ensure the formal buddy allocation specification preserves a set of properties which guarantee its functional correctness. In next two subsections, we build a security model and prove the specification preserves integrity of the memory structures.

\subsection{A Security Model}\label{sec:securitymodel}
Integrity is the assurance that information is trustworthy and accurate. To achieve this, data must not be changed in transit. In this subsection, we try to prove the integrity property for buddy allocation specification. For this purpose, we firstly design a security model which consists of a nondeterministic state machine and the integrity property conditions. This part of work is following the work form~\cite{reg_securitymodel}.

\subsubsection{Memory State Machine} is designed to be event based. Thus, $\mathcal{S}$ represents the state space and $\mathcal{E}$ is the set of event labels. The state-transition function is characterized by $\varphi$, which has the form of $\varphi: \mathcal{E} \rightarrow \mathbb{P}(\mathcal{S} \times \mathcal{S})$. The state machine must execute from a initial state, therefore, $s_0 \in \mathcal{S}$ which is on behalf of the initial state must be included in this machine. The definition of this state machine is as follows.

\begin{definition} [State Machine]
\vspace{-7pt}
\end{definition}	
{\footnotesize
\begin{align*}
\mathcal{M} = \langle \mathcal{S}, \mathcal{E}, \varphi, s_0 \rangle
\end{align*}
}
\vspace{-12pt}

Based on the state machine above, we introduce some auxiliary functions: function \textbf{execution(s, es)} takes a state \emph{s} and a sequence of events \emph{es}, then returns the set of final states; function \textbf{reachable(s)} (denoted as $\mathcal{R}(s)$) checks the reachability of a state \emph{s} from the initialized state $s_0$ by the \emph{execution} function: \emph{$\exists$es.\ s $\in$ execution($s_0$, es)}.

Next, we add the concept of partitions to represent the entities that execute the state-transition function. Partitions are the basic domains. In addition, we introduce partition scheduling as a domain \textbf{scheduler}. And we give the strict restriction that \emph{scheduler} cannot be interfered by any other domains. Its aim is to ensure that \emph{scheduler} does not leak information by its scheduling decisions. Therefore, the domains ($\mathcal{D}$) in $\mathcal{M}$ are the configured partitions ($\mathcal{P}$) and the scheduler ($\mathbb{S}$), $\mathcal{D}$ = $\mathcal{P}$ $\cup$ $\lbrace$$\mathbb{S}$$\rbrace$. Function \textbf{dom(s, e)} gives which partition is currently executing \emph{e} in the state \emph{s} by consulting the \emph{scheduler}.

\subsubsection{Integrity Definition} is referenced to~\cite{reg_noninterference} which provides a formalism for the specification of security policies. The main idea in this article is that domain \emph{u} is non-interfering with domain \emph{v} if no action performed by \emph{u} can influence the subsequence outputs seen by \emph{v}. According to this article, we use the concepts of state equivalence and interfering to construct integrity property for our security model.

Firstly, state equivalence (denoted as $\sim$) means that states are identical for a domain seen by it. For example, some certain collections that accessed only by a domain are indistinguishable at two different states. We use $\equidom{s}{d}{t}$ to represent \emph{s} and \emph{t} are identical for domain \emph{d}.

By the concept of state equivalence, interfering (denoted ad $\interf$) means that the state equivalence of some domain is broken due to the operations by another domain. And $\ninterf$ is the opposite relation of $\interf$. Since the \emph{scheduler} can schedule other domains, it can interfere with them. However, the \emph{scheduler} cannot be interfered by any other domains to ensure that the \emph{scheduler} does not leak information by its scheduling decisions.

With these two concepts, we can easily define the integrity property conditions as follows.

\begin{definition} [Integrity Property Conditions]
\vspace{-7pt}
\end{definition}	
{\footnotesize
\begin{align*}
integrity(e) \triangleq\ &\forall d\ s\ s'.\ \mathcal{R}(s) \wedge dom(s, e) \ninterf d \wedge (s, s') \in \varphi(e)\\
&\longrightarrow (\equidom{s}{d}{s'})
\end{align*}
}
\vspace{-12pt}

From the conditions, if the current domain which is executing \emph{e} in state \emph{s} promises not to interfere any other domains, then the state \emph{s} and the final state \emph{s'} are identified as state equivalence seen by any other domains. That is to say the current domain has only access to its own space. Therefore, the integrity property conditions guarantee that the information is trustworthy and accurate.

\subsubsection{Security Model} is defined as follows based on the discussion above.

\begin{definition} [Security Model] \\
{\footnotesize
\[\mathcal{S\_M} = \langle \mathcal{M}, \mathcal{D}, dom, \interf, \sim \rangle\] with assumptions as follows.
\begin{enumerate}
\item $\forall$d $\in$ $\mathcal{D}$. $\mathbb{S}$ $\interf$ d
\item $\forall$d $\in$ $\mathcal{D}$. d $\interf$ $\mathbb{S}$ $\longrightarrow$ d = $\mathbb{S}$
\item $\forall$s t e. $\equidom{s}{\mathbb{S}}{t}$ $\longrightarrow$ dom(s, e) = dom(t, e)
\item $\forall$s e. $\mathcal{R}(s)$ $\longrightarrow$ $\exists$s'. (s, s') $\in$ $\varphi(e)$
\item $\forall$e. integrity(e)
\end{enumerate}
}
\end{definition}
\vspace{-7pt}

This security model constructs a sequential model for event-based specification to verify the integrity property. Next, we will instantiate this security model with our buddy allocation specification. We are going to find that if our buddy allocation specification satisfies the integrity property conditions.

\subsection{Instantiation and Security Proofs}\label{sec:securityproof}
In this part, we add interfaces to the buddy allocation specification, and package it into an event specification. We think of this event specification as an instantiated security model. Then our work is to prove the instantiated model satisfy the integrity property.

\subsubsection{Instantiation}
A global state records all the information like domains and memory resources. A \emph{state} in type \emph{record} mainly consists of the currently running domain (\textbf{Cur}), a collection of entire domains (\textbf{Parset}), a collection of whole memory Blocks (\textbf{Bloset}) and the memory address spaces occupied by the partition (characterized by function \textbf{Par\_Mem: partition $\rightharpoonup$ Mem\_Add}, \emph{Mem\_Add} is in the type of \emph{idset}).

To construct interfaces \textbf{alloc\_memory} and \textbf{free\_memory}, it only needs to update \emph{Par\_Mem} information in \emph{state} according to successful or failing results returned by functions \emph{alloc} and \emph{free}. Another interface function is scheduler, it arbitrarily selects partitions to mark the \emph{Cur} in \emph{state}. These three interface functions are defined as follows. In addition, function \textbf{allocid} returns the \emph{ID} of allocated Leaf node in allocation operation.

\begin{definition} [Allocate Memory Interface]
\vspace{-7pt}
\end{definition}
{\footnotesize
\begin{align*}
alloc\_&memory\ s\ rlv \triangleq \\
&if\ snd\ (alloc\ (Bloset\ s)\ rlv) = True\ then \\
&\ \ \ \ s{\isasymlparr} Par\_Mem := (Par\_Mem\ s\ (Cur\ s)) \\
&\ \ \ \ \ \ \ \cup \lbrace allocid\ (alloc\ (Bloset\ s)\ rlv) \rbrace {\isasymrparr} \\
&else\ s
\end{align*}
}
\vspace{-12pt}

\begin{definition} [Deallocate Memory Interface]
\vspace{-7pt}
\end{definition}
{\footnotesize
\begin{align*}
free\_&memory\ s\ b \triangleq \\
&if\ snd\ (free\ (Bloset\ s)\ b) = True\ then \\
&\ \ \ \ s{\isasymlparr} Par\_Mem := (Par\_Mem\ s\ (Cur\ s)) - \lbrace snd\ b \rbrace {\isasymrparr} \\
&else\ s
\end{align*}
}
\vspace{-12pt}

\begin{definition} [Scheduler]
\vspace{-7pt}
\end{definition}
{\footnotesize
\begin{align*}
scheduler\ s \triangleq s{\isasymlparr} Cur := SOME\ p.\ p \in (Parset\ s) {\isasymrparr}
\end{align*}
}
\vspace{-12pt}

With these interface functions, then we give the state-transition function \textbf{exec\_event(E)} as a instantiation of $\varphi$. Event function \emph{E} includes the interface functions \emph{alloc\_memory}, \emph{free\_memory} and \emph{scheduler}.

\begin{definition} [State-transition]
\vspace{-7pt}
\end{definition}
{\footnotesize
\begin{align*}
exec\_event\ E &\triangleq\ \lbrace (s, s').\ s' = \lbrace (E\ s) \rbrace \\
&\wedge E \in \lbrace alloc\_memory,\ free\_memory,\ scheduler \rbrace \rbrace
\end{align*}
}
\vspace{-12pt}

Finally, we give the instantiation of integrity property by introducing concrete meanings to $\interf$ and $\sim$. In this paper, our goal is to preserve the integrity of memory address spaces. To be more specific, the memory areas of one domain can not be accessed by another domain except for \emph{scheduler} domain. Therefore, we have such considerations: the interfering entities are domains themselves and \emph{scheduler} domain; the state equivalence should be like that the \emph{Mem\_Add} of one domain preserving identical during execution of another domain. We give the instantiations of $\interf$ and $\sim$ as follows. Functions \textbf{is\_scheduler} and \textbf{is\_partition} take a domain and check whether it is a \emph{scheduler} domain or a \emph{partition} domain.

\begin{definition} [Instantiation of $\interf$ by Domains]
\vspace{-7pt}
\end{definition}
{\footnotesize
\begin{align*}
d1 \interf d2 \triangleq (d1 = d2) \vee is\_scheduler\ d1
\end{align*}
}
\vspace{-12pt}

\begin{definition} [Instantiation of $\sim$ by States and Domains]
\vspace{-7pt}
\end{definition}
{\footnotesize
\begin{align*}
\equidom{s}{d}{t} &\triangleq\ (is\_scheduler\ d \longrightarrow Cur\ s = Cur\ t) \\
&\wedge (is\_partition\ d \longrightarrow Par\_Mem\ s\ d = Par\_Mem\ t\ d)
\end{align*}
}
\vspace{-17pt}

\subsubsection{Security Proofs}
To prove the instantiated model is a security model, we have to prove item 1 to 5 in the definition of $\mathcal{S\_M}$. The first two assumptions are preserved by the interfering $\interf$ definition. The third assumption is preserved by $\sim$ for \emph{scheduler} domain. The fourth assumption of reachability is preserved with function \emph{exec\_event(E)} through a lemma as follows.

\begin{lemma} [Reachability]
\vspace{-7pt}
\end{lemma}
{\footnotesize
\begin{align*}
\forall s\ E.\ \mathcal{R}(s) \longrightarrow \exists s'.\ (s, s') \in exec\_event(E)
\end{align*}
}
\vspace{-12pt}

To prove the last assumption \emph{integrity(E)}, we add preconditions like $\mathcal{R}(s)$, \emph{is\_partition (Cur s)} and \emph{(Cur s) $\ninterf$ d} in implication expression for each interface function. We prove the theorem of integrity for each interface function through lemmas as follows.

\begin{lemma} [Integrity of alloc\_memory]
\vspace{-7pt}
\end{lemma}
{\footnotesize
\begin{align*}
\forall d\ s\ s'\ rlv.\ &\mathcal{R}(s) \wedge is\_partition\ (Cur\ s) \wedge (Cur\ s) \ninterf d \\
&\wedge s' = alloc\_memory\ s\ rlv \longrightarrow \equidom{s}{d}{s'}
\end{align*}
}
\vspace{-12pt}

\begin{lemma} [Integrity of free\_memory]
\vspace{-7pt}
\end{lemma}
{\footnotesize
\begin{align*}
\forall d\ s\ s'\ b.\ &\mathcal{R}(s) \wedge is\_partition\ (Cur\ s) \wedge (Cur\ s) \ninterf d \\
&\wedge s' = free\_memory\ s\ b \longrightarrow \equidom{s}{d}{s'}
\end{align*}
}
\vspace{-12pt}

\begin{lemma} [Integrity of scheduler]
\vspace{-7pt}
\end{lemma}
{\footnotesize
\begin{align*}
\forall d\ s\ s'.\ is\_scheduler\ (Cur\ s) \wedge (Cur\ s) \ninterf d \longrightarrow \equidom{s}{d}{s'}
\end{align*}
}
\vspace{-12pt}

\begin{theorem}
$\forall$E $\in$ $\lbrace$alloc\_memory, free\_memory, scheduler$\rbrace$. integrity(E)
\end{theorem}

In the end, we prove that the event specification based on the buddy allocation specification satisfies the integrity property and is really a security model. According to the instantiation of $\interf$, one partition domain (the \emph{scheduler} domain can interfere any partition domain) cannot influence the memory address spaces of other partition domains. The integrity of memory address spaces ensures that memory information is trustworthy and accurate.

\section{Verification}
In this section we will show that the formal specification introduced in the previous section preserves a set of properties guaranteeing its functional correctness in Section~\ref{sec:functional}. As a security property, we also prove that the specification preserves integrity of the memory structures in Section~\ref{sec:securitymodel} and Section~\ref{sec:securityproof}. All the lemmas and theorems present in this section have been proven in the Isabelle/HOL theorem prover. We omit the proofs due to lack of space, but the interested reader can access the mechanize proofs on the project website.

\subsection{Functional correctness}\label{sec:functional}
We first formulate and prove the desired properties for the allocation and deallocation services with regards to preservation of the memory layouts. Note that models for \textbf{alloc} and \textbf{free} return a tuple $(BlockTree \times Bool)$, where the first element is the new memory layouts, and the second one indicates the success or failure of the function. For simplicity on the presentation of the lemmas we consider that the models only return the new state of the memory layouts.

\subsubsection{Allocation}\label{sec:functionalalloc}
We first show that the allocation service does not change the state when none of the memory pools in a set $bs$ have any free block big enough to allocate a request of size $s$. 

\begin{lemma} [Allocation Failure]
\label{lemma:no_free_space}
\begin{align*}
\neg\ exists\_freelevel\ bs\ \Delta_s \longrightarrow (alloc\ bs\ \Delta_s) = bs
\end{align*}
\end{lemma}

As described in Section~\ref{sec:buddy} to allocate a memory block of size $s$, there must be a free block at a level higher or equal than $\Delta_s$. So under the assumption that there does not exist such a block, the allocation procedure leaves the state unchanged.

Then we show in Lemma~\ref{lemma:alloc_alloc} that if there is a memory pool with a block big enough to allocate the requested size $s$, then \textbf{alloc} keeps constant the set of allocated block at any level different from $\Delta_s$ (1), and adds the allocated block at level $\Delta_s$ (2). That is, the allocated blocks at level $\Delta_s$ after the allocation contains a new block that did not belong to level $\Delta_s$ before the allocation, whereas the rest of allocated blocks at level $\Delta_s$ do not change.

\begin{lemma} [Allocsets for Allocation]
\label{lemma:alloc_alloc}
\begin{align*}
&exists\_freelevel\ bs\  \Delta_s \longrightarrow \\
&(1)\forall l \ne \Delta_s.\ alloc\_lvl\ (alloc\ bs\ \Delta_s)\ l = alloc\_lvl\ bs\ l\ \wedge\\
&(2)\exists le.\ le \notin alloc\_lvl\ bs\ \Delta_s\ \wedge\\
&\ \ \ \ \ le \in alloc\_lvl\ (alloc\ bs\ \Delta_s)\ \Delta_s\ \wedge\\
&\ \ \ \ \ alloc\_lvl\ (alloc\ bs\ \Delta_s)\ \Delta_s = alloc\_lvl\ bs\ \Delta_s \cup \lbrace le \rbrace
\end{align*}
\end{lemma}

With regards to free blocks, for better presentation we split verification into two lemmas. Lemma~\ref{lemma:free_directalloc} for direct allocation, i.e., the case in which level $\Delta_s$ has free blocks and there is no split, and Lemma~\ref{lemma:free_indirectalloc} for indirect allocation in which $\Delta_s$ has no free blocks, but rather a higher level $lm$. In Lemma~\ref{lemma:free_directalloc}, if there is a memory pool with a block with the minimum necessary size to allocate the requested size $s$, therefore located at level $\Delta_s$, then for any level $l$ different from $\Delta_s$, the set of free blocks at $l$ does not change after the allocation. And \textbf{alloc} removes the block being allocated from the free blocks at level $\Delta_s$. That is, there exists a block $le$ that belongs to the free blocks at level $\Delta_s$ before the allocation but it does not belong to the free blocks after the allocation, whereas the rest of free blocks at level $\Delta_s$ do not change.

\begin{lemma} [Freesets for Direct Allocation]
\label{lemma:free_directalloc}
\begin{align*}
&exists\_freelevel\ bs\ \Delta_s\ \wedge\\
&freesets\_ml\ bs\ \Delta_s = \Delta_s \longrightarrow\\
&\forall l \ne \Delta_s.\ free\_lvl\ (alloc\ bs\ \Delta_s)\ l =  free\_lvl\ bs\ l\ \wedge\\
&\exists le.\ le \in free\_lvl\ bs\ \Delta_s\ \wedge\\
&\ \ \ \ \ le \notin free\_lvl\ (alloc\ bs\ \Delta_s)\ \Delta_s\ \wedge\\
&\ \ \ \ \ free\_lvl\ bs\ \Delta_s =  free\_lvl\ (alloc\ bs\ \Delta_s)\ \Delta_s \cup \lbrace le \rbrace
\end{align*}
\end{lemma}

Lemma~\ref{lemma:free_indirectalloc} is more interesting when $\Delta_s$ does not have free blocks. In this case, a free block in a level $lm < \Delta_s$ is split till the level $\Delta_s$, as consequence we have that: (1) the set of free blocks at any level $l$ higher than $lm$ or lower than $\Delta_s$ does not change; (2) for any level $l$ between $lm$ and $\Delta_s$ the number of free blocks at $l$ after the allocation is exactly $3$; and (3) the allocated block is removed from the free blocks after the allocation. Note that in the second case, according to the function \textbf{freesets\_ml}, $lm$ is the lower level containing free blocks with a size bigger than $s$, therefore the set of free blocks at any level $l$ between $lm$ and $\Delta_s$ is empty before the allocation, and the allocation introduces three free leaves at each level as result of the split.
 
\begin{lemma} [Freesets for Indirect Allocation]
\label{lemma:free_indirectalloc}
\end{lemma}
\vspace{-7pt}
\begin{align*}
&exists\_freelevel\ bs\ \Delta_s \wedge freesets\_ml\ bs\ \Delta_s = lm\ \wedge\\
&lm < \Delta_s \longrightarrow\\
&(1) \forall l < lm \vee l > \Delta_s.\\
&\ \ \ \ \ free\_lvl\ (alloc\ bs\ \Delta_s)\ l = free\_lvl\ bs\ l\ \wedge\\
&(2) \forall l > lm \wedge l \le \Delta_s.\\
&\ \ \ \ \ free\_lvl\ bs\ l = \emptyset \wedge |free\_lvl\ (alloc\ bs\ \Delta_s)\ l| = 3\\
&(3) \exists le.\ le \in free\_lvl\ bs\ lm\ \wedge\\
&\ \ \ \ \ le \notin free\_lvl\ (alloc\ bs\ \Delta_s)\ lm\ \wedge\\
&\ \ \ \ \ free\_lvl\ bs\ lm = free\_lvl\ (alloc\ bs\ \Delta_s)\ lm \cup \lbrace le \rbrace\ 
\end{align*}

\subsubsection{Deallocation}\label{sec:functionalDealloc}
For deallocation, we first show in Lemma~\ref{lemma:deallocate_fail1} and Lemma~\ref{lemma:deallocate_fail2} that the deallocation service indeed does not change the memory layouts when the block to deallocate does not belong to any memory pool in the memory layouts, or when it exists but it has not been allocated.

\begin{lemma} [Deallocation Failure 1]
\label{lemma:deallocate_fail1}
\begin{align*}
\nexists bt \in bs.\ b \in set\ bt \longrightarrow (free\ bs\ b) = bs
\end{align*}
\end{lemma}
	
\begin{lemma} [Deallocation Failure 2]
\label{lemma:deallocate_fail2}
\begin{align*}
\exists bt \in bs.\ &b\in set\ bt \wedge fst\ b = FREE \longrightarrow \\ 
&(free\ bs\ b) = bs
\end{align*}
\end{lemma}

Then we show in Lemma~\ref{lemma:alloc_deallocation} that the deallocation process carries out a correct transition during a successful deallocation process. It describes that the \emph{Leaf} node to be disposed does not belong any more to the allocated set on the level $l_b$ which it belongs to. Analogously to the allocation algorithm, for any level $l$ different than $l_b$, the allocated set of elements at such level does not change after the deallocation.

\begin{lemma} [Allocsets for Deallocation]
\label{lemma:alloc_deallocation}
\end{lemma}
\vspace{-7pt}
\begin{align*}
&\exists bt \in bs.\ b \in set\ bt \wedge fst\ b \neq FREE\ \wedge\\
&\ \ \ \ \ \ \ level\ bt\ b = l_b \longrightarrow\\
&\ \ \ \ (\forall l \ne l_b.\ alloc\_lvl\ (free\ bs\ b)\ l = alloc\_lvl\ bs\ l)\ \wedge\\
&\ \ \ \ b \in alloc \_lvl\ bs\ l_b \wedge b \notin alloc\_lvl\ (free\ bs\ b)\ l_b\ \wedge\\
&\ \ \ \ alloc\_lvl\ bs\ l_b = alloc\_lvl\ (free\ bs\ b)\ l_b \cup \lbrace b \rbrace
\end{align*}
\vspace{-12pt}

With regards to free blocks, the deallocation process may remove free memory blocks during the coercing procedure. In this case, we need to ensure that there is a level $lvl$ for which all the free blocks before the deallocation are also free, and it contains an additional block $b'$ that did not belong to the free blocks of that level before deallocation (1). Note that $lvl$ has to be (a) smaller, i.e., it is a higher level as result of merging, or (b) equal than $l_b$, i.e., there was no merging.

For (a), then we show (a.1) that for any level smaller than $lvl$ or bigger than $l_b$ the set of free blocks does not change. Since the merge process goes from $l_b$ up to $lvl$ and  $lvl$ is the level in which we have the new free block, then we can deduce that $lvl$ is the first level in which all the buddies are not \emph{FREE} and hence they are not merged. In (a.2) we show that the merging process has removed the buddies of $b$ and subsequently nodes at any level between $lvl$ and $l_b$, i.e., the set of free blocks for any level between $lvl$ and $l_b$ after deallocation is a subset of the set of free blocks before deallocation. Note that the number of removed blocks is exactly 3 per level. At level $l_b$, $b$ was allocated, so it did not belong to the set of free blocks before deallocation, only its 3 buddies belonged to that set. At any level higher than $l_b$ up to $lvl$ there were 3 free blocks together with the logical block split into lower levels.

For (b), where there was no merging, it is enough to show that for any level $l$ different from $l_b$ the set of free blocks at $l$ remains the same. Lemma~\ref{lemma:free_deallocation} expresses these conditions.

\begin{lemma} [Freesets for Deallocation]
\label{lemma:free_deallocation}
\end{lemma}
\begin{align*}
&\exists bt \in bs.\ b \in set\ bt \wedge fst\ b \neq FREE\ \wedge\\
&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ level\ bt\ b = l_b \longrightarrow\\
&\ \ (1)\exists lvl\ b'.\ b' \notin free\_lvl\ bs\ lvl\ \wedge  \\
&\ \ \ \ \ \ \ b' \in free\_lvl\ (free\ bs\ b)\ lvl\ \wedge\\
&\ \ \ \ \ \ \ free\_lvl\ (free\ bs\ b)\ lvl = free\_lvl\ bs\ lvl \cup \lbrace b' \rbrace\ \wedge \\
& \ \ \ \ (a)(lvl < l_b \longrightarrow \\
&\ \ \ \ \ \ (a.1)\forall l < lvl \vee l > l_b.\ \\ 
&\ \ \ \ \ \ \ \ \ \ \ \ \ free\_lvl\ (free\ bs\ b)\ l = free\_lvl\ bs\ l\ \wedge\\
&\ \ \ \ \ \ (a.2)\forall l > lvl \wedge l \le l_b. \\
&\ \ \ \ \ \ \ \ \ \ (free\_lvl\ (free\ bs\ b)\ l) \subset (free\_lvl\ bs\ l)\ \wedge\\
&\ \ \ \ \ \ \ \ \ \ |free\_lvl\ bs\ l| = |free\_lvl\ (free\ bs\ b)\ l| + 3)\ \wedge\\
& \ \ \ \ (b)(lvl = l_b \longrightarrow \\
&\ \ \ \ \ \ \forall l \ne l_b.\ free\_lvl\ (free\ bs\ b)\ l = free\_lvl\ bs\ l)
\end{align*}

\subsubsection{Correct Merging}
The buddy memory allocation algorithm may reduce the fragmentation by invoking the merge function during the process of deallocation to merge buddy blocks that are free, as shown in Fig.~\ref{fig:merginfreeblocks}. Previous lemmas do not show that the merging procedure is correct, so we show here that the merging process is correctly carried out. This can be reduced to show that the memory layouts preserve an invariant saying that not all the buddy memory blocks are free. To achieve this, we first define the notion of all free buddy memory block using the definition below, where function \textbf{child} gives us a set of all immediate child nodes of a \emph{Tree} and \textbf{leaf} is a predicate checking whether a node is terminal or not:

\begin{definition} [Four Free Leaves Belong to the Same Node]
\label{def:FF4}
\end{definition}
\vspace{-7pt}
\begin{align*}
is\_FFL\ btree \triangleq\ &\forall chtree \in child\ btree.\ leaf\ chtree\ \wedge \\
&fst\ chtree = FREE
\end{align*}
\vspace{-12pt}

Operating systems initialize the whole memory into a series of free blocks, and these memory blocks are in the form of root nodes which are not split at the very beginning. This initial state satisfies not-existence of \emph{FFL} trees. Then according to Lemma~\ref{lemma:allocffl} and Lemma~\ref{lemma:deallocffl}, any state after initialization satisfies non-existence of \emph{FFL} trees no matter whether the operating system performs an allocation or a deallocation operation. Therefore, we ensure that the whole memory system preserves this property. Furthermore, it shows that the buddy allocation specification reduces the fragmentation by means of the merge operation, since it make available to applications blocks with a bigger size than what it was initially disposed.

\begin{lemma} [Non-existence of FFL during Allocation]
\label{lemma:allocffl}
\begin{align*}
\forall b \in\ &bs.\ \neg\ is\_FFL\ b \longrightarrow \\
&\forall b \in (alloc\ bs\ \Delta_s).\ \neg\ is\_FFL\ b
\end{align*}
\end{lemma}

\begin{lemma} [Non-existence of FFL during Deallocation]
\label{lemma:deallocffl}
\begin{align*}
\forall b \in\ &bs.\ \neg\ is\_FFL\ b \longrightarrow \\
&\forall b \in (free\ bs\ b).\ \neg\ is\_FFL\ b
\end{align*}
\end{lemma}

\subsubsection{Memory Isolation}
Memory isolation ensures non-overlapping of the allocated address space. In Section~\ref{statedes} we show that the memory model uses a natural number as a block identifier \emph{ID}. The \emph{ID} helps us to uniquely identify each physical memory block in a memory pool.

Definition~\ref{def:dif} introduces a judgment stating that \emph{Leaf} nodes in a set of memory pools all have different \emph{ID}. This definition checks that for any memory pool $b$ in the memory layouts $bs$, and any memory block $l$ in $b$, i.e. a terminal node of $b$, there is not any other $l'$, different than $l$, and other memory pool $b'$ in $bs$ where the \emph{ID} of $l$ is equal to the \emph{ID} of $l'$.

\begin{definition} [Different IDs]
\label{def:dif}
\end{definition}
\vspace{-7pt}
\begin{align*}
is\_&different\ bs \triangleq\\
&\forall b \in bs.\ \forall l \in set\ b.\ \nexists l'\ b'.\ l' \in set\ b' \wedge b' \in bs\ \wedge\\
&l' \ne l \wedge get\_id\ l' = get\_id\ l
\end{align*}
\vspace{-12pt}

Lemma~\ref{lemma:id_alloc} and Lemma~\ref{lemma:id_dealloc} show that uniqueness of IDs is an invariant to the allocation and deallocation procedures.

\begin{lemma} [Different IDs during Allocation] \label{lemma:id_alloc}
\begin{align*}
is\_different\ &bs \longrightarrow is\_different\ (alloc\ bs\ \Delta_s)
\end{align*}
\end{lemma}

\begin{lemma} [Different IDs during Deallocation] \label{lemma:id_dealloc}
\begin{align*}
is\_different\ &bs \longrightarrow is\_different\ (free\ bs\ b)
\end{align*}
\end{lemma}

Considering that a block ID allows us to uniquely identify a memory block, the lemma on uniqueness of blocks and Lemma~\ref{lemma:alloc_alloc} allows to infer non-overlapping of allocation of memory blocks. That is, that two different allocations do not assign the same memory block.

Note that although our level of abstraction does not consider memory addresses, it would be easy to refine this model to include memory addresses and identify the domain of addresses of a memory block as a function in terms of the location of the memory block in the tree.

\subsection{A Security Model}\label{sec:securitymodel}
Integrity is the assurance that information is trustworthy and accurate. To achieve this, data must not be changed in transit. In this subsection, we prove integrity of the data allocated by a buddy allocation specification. For this purpose, we follow the work from~\cite{reg_securitymodel} to firstly design a security model, which consists of a nondeterministic state machine, and then to specify the integrity property and prove that it is an invariant on the memory allocator.

\subsubsection{Memory State Machine}
We define a memory state machine as tuple $\mathcal{M} = \langle \mathcal{S}, \mathcal{E}, \varphi, s_0 \rangle$. $\mathcal{S}$ represents the state space,  $s_0 \in \mathcal{S}$ is the initial machine state, and $\mathcal{E}$ is the set of event labels. The state-transition function is characterized by $\varphi$, of type $\varphi: \mathcal{E} \rightarrow \mathbb{P}(\mathcal{S} \times \mathcal{S})$, where $\mathbb{P}(n)$ is the powerset of the set $n$.

Based on the state machine above, we introduce some auxiliary functions: function \textbf{execution(s, es)} takes a state \emph{s} and a sequence of events \emph{es}, and then returns the set of final states; function \textbf{reachable(s)} (denoted as $\mathcal{R}(s)$) checks the reachability of a state \emph{s} from the initialized state $s_0$ by the \emph{execution} function: \emph{$\exists$es.\ s $\in$ execution($s_0$, es)}.

Next, we add the concept of domains, also referred as partitions, to represent the entities that execute the state-transition function. In addition, we introduce partition scheduling as a domain \textbf{scheduler}. Therefore, the domains ($\mathcal{D}$) in $\mathcal{M}$ are the configured partitions ($\mathcal{P}$) and the scheduler ($\mathbb{S}$), $\mathcal{D}$ = $\mathcal{P}$ $\cup$ $\lbrace$$\mathbb{S}$$\rbrace$.

\subsubsection{Integrity Definition}
We use the notion of integrity from~\cite{reg_noninterference}, which provides a formalism for the specification of security policies. A domain \emph{u} is non-interfering with domain \emph{v} if no action performed by \emph{u} can influence the subsequence outputs seen by \emph{v}. We define the notion of integrity in our security model using the concepts of state equivalence and interfering.

Firstly, state equivalence is denoted as $\sigma_1 \sim \sigma_2$ is a relation in $(\mathbb{S}\times\mathbb{S})$. State equivalence of $\sigma_1$ and $\sigma_2$ on a domain $d$ is denoted as $\equidom{\sigma_1}{d}{\sigma_2}$.

Interference is a relation in $(\mathcal{D}\times\mathcal{D})$ and is denoted as $a \interf b$, representing that domain $a$ interfere with domain $b$. We use $a \ninterf b$ to express that a domain $a$ does not interfere domain $b$.

Finally, integrity of an event $e$ is defined as:

\begin{definition} [Integrity]
\label{def:integrity}
\begin{align*}
&integrity(e) \triangleq \forall d\ s\ s'.\\
&\mathcal{R}(s) \wedge dom(s,\ e) \ninterf d \wedge (s,\ s') \in \varphi(e) \longrightarrow (\equidom{s}{d}{s'})
\end{align*}
\end{definition}

$dom(\sigma, e)$ is a function from pairs $(\mathcal{S}\times \mathcal{E})$ to $\mathcal{D}$, specifying the domain executing an event $e$ on a state $\sigma$. The notion of integrity states that for any domain $d$, and a reachable state $s$ from the initial state $s_0$, if the domain executing the event $e$ in $s$ does not interfere with $d$, then for any state $s'$ that $e$ can transit to from $s$, $s$ is equivalent to $s'$ in the domain $d$. That is, if the domain executing $e$ is not able to interfere with $d$, then the execution of $e$ does not modify the information that domain $d$ observes.

\subsubsection{Security Model} We define the security model as:

\begin{definition} [Security Model]\\
The security model is a tuple \[\mathcal{S\_M} = \langle \mathcal{M}, \mathcal{D}, dom, \interf, \sim \rangle\] assuming the following assumptions.
\begin{enumerate}
\item $\forall$d $\in$ $\mathcal{D}$. $\mathbb{S}$ $\interf$ d
\item $\forall$d $\in$ $\mathcal{D}$. d $\interf$ $\mathbb{S}$ $\longrightarrow$ d = $\mathbb{S}$
\item $\forall$s t e. $\equidom{s}{\mathbb{S}}{t}$ $\longrightarrow$ dom(s, e) = dom(t, e)
\item $\forall$s e. $\mathcal{R}(s)$ $\longrightarrow$ $\exists$s'. (s, s') $\in$ $\varphi(e)$
\item $\forall$e. integrity(e)
\end{enumerate}
\end{definition}

The security model is tuple composed of a state machine $\mathcal{M}$, a set of execution domains $\mathcal{D}$, a function $dom$, and the relations for interference between domains and equivalence between states. The assumptions of the model represent that: the scheduler interferes with any execution domain (1); an execution domain $d$ cannot interfere with the scheduler, unless $d$ is the scheduler itself (2); two states $s$ and $t$ are equivalent on the scheduler only if the execution domain of $s$ and $t$ is the same on the execution of any event $e$ (3); any event $e$ is defined on any reachable state (4); all the events must preserve the integrity relation (5).

This security model constructs a sequential model for event-based specifications which ensures the preservation of the integrity property for any possible execution trace on $\mathcal{M}$. In the next section, we instantiate the security model with our buddy allocation specification.

\subsection{Instantiation and Security Proofs}\label{sec:securityproof}
In this part, we construct an event specification by adding interfaces to the buddy allocation specification introduced in Section~\ref{sec:spec}. We instantiate the security model specifying the function for execution domains, and the relations of domain interference and state equivalence. We also prove that the wrapped buddy allocation events satisfy the integrity property.

\subsubsection{Instantiation}
We first define the notion of state used in the memory state machine $\mathcal{M}$ as $\Sigma = \langle \mathcal{MS}, \xi, \mathcal{A} \rangle$, where $\mathcal{MS}$ is a set of memory pools, i.e., the memory state; $\xi$ is the scheduler domain used to instantiate the function $dom$ in the security model; and $\mathcal{A}$ is a function from execution domains to memory blocks identifiers, which holds the memory blocks that have been allocated to each execution domain. We use $\mathcal{A}$ to instantiate the equivalence function among domains.

The events $\mathcal{E}$ in the security model is a set composed of allocation, deallocation, and scheduler event. The interfaces for the allocation and deallocation use the \textbf{alloc} and \textbf{free} functions defined in Section~\ref{sec:spec} to update the internal information of the memory and the blocks identifier used by the domain executing the event. The Scheduler is an event function that sets $\xi$ non-deterministically with any execution domain. Note that we constrain the execution of allocation and free functions to be carried out by an execution domain that is not the scheduler, and the execution of the scheduler by the scheduler domain. The transition relation is defined as:

\begin{definition} [Allocate Memory Interface]
\end{definition}
\vspace{-7pt}
\begin{align*}
\forall &\Delta_s.\ \varphi\ allocate\_memory\ \Sigma \triangleq\\
&if\ snd\ (alloc\ (\mathcal{MS}\ \Sigma)\ \Delta_s) = True \wedge \xi\ \Sigma \neq \mathbb{S}\\
&then\ \langle (alloc\ (\mathcal{MS}\ \Sigma)\ \Delta_s),\ \xi\ \Sigma,\\
&\ \ \ \ \ \ \ \ \mathcal{A}[\xi := \mathcal{A}\ \xi \cup \lbrace allocid\ (alloc\ (\mathcal{MS}\ \Sigma)\ \Delta_s) \rbrace] \rangle\\
&else\ \Sigma
\end{align*}
\vspace{-12pt}

\begin{definition} [Deallocate Memory Interface]
\end{definition}
\vspace{-7pt}	
\begin{align*}
\forall &b.\ \varphi\ free\_memory\ \Sigma \triangleq\\ 
&if\ snd\ (free\ (\mathcal{MS}\ \Sigma)\ b) = True \wedge \xi\ \Sigma \neq \mathbb{S}\\
&then\ \langle (free\ (\mathcal{MS}\ \Sigma)\ b),\ \xi\ \Sigma,\\
&\ \ \ \ \ \ \ \ \mathcal{A}[\xi := \mathcal{A}\ \xi - \lbrace allocid\ (free\ (\mathcal{MS}\ \Sigma)\ b) \rbrace] \rangle\\
&else\ \Sigma
\end{align*}
\vspace{-12pt}

\begin{definition} [Scheduler]
\end{definition}
\vspace{-7pt}	
\begin{align*}
\varphi\ scheduler\ &\Sigma \triangleq\\
&if\ \xi\ \Sigma = \mathbb{S}\ then\\
&\ \ \ \ \langle \mathcal{MS}\ \Sigma,\ SOME\ p.\ p \in \mathcal{D},\ \mathcal{A}\ \Sigma \rangle\\
&else\ \Sigma
\end{align*}
\vspace{-12pt}

Where $\mathcal{MS}\ \Sigma$, $\xi\ \Sigma$, and $\mathcal{A}\ \Sigma$ are respectively the projections of $\mathcal{MS},\ \xi,\ \mathcal{A}$ in $\Sigma$. The notation $f[i:=v]$ sets the image of $i$ to $v$ in $f$, and for any $j\neq i$, $f\ j = f[i:=v]\ j$. The function \textbf{allocid} returns the \emph{ID} of the block allocated or freed by allocation and deallocation events.

Seeking integrity of the memory between domains, two different execution domains cannot interfere each with the other. On the other hand, since the scheduler $\mathbb{S}$ changes the current execution domain, it is necessary to set that it can interfere with any domain. We instantiate the interference relation as:

\begin{definition} [Instantiation of $\interf$ by Domains]
\begin{align*}
d1 \interf d2 \triangleq (d1 = d2) \vee d1 = \mathbb{S}
\end{align*}
\end{definition}

The state equivalence for an execution domain different from the scheduler, hence a partition, must consider the set of block identifiers that have been allocated to it, given by $\mathcal{A}\ \Sigma\ d$ for the domain $d$ in the state $\Sigma$. We then say that two states are equivalents in a partition $d$ if the set of a allocated blocks for $d$ is the same in both states. The scheduler must check that the projection of $\xi$ is equal in the relation, that is the scheduler did not change. the Formally:

\begin{definition} [Instantiation of $\sim$ by States and Domains]
\begin{align*}
\equidom{s}{d}{t} &\triangleq\ (d = \mathbb{S} \longrightarrow \xi\ s = \xi\ t)\ \wedge \\
&\ \ \ \ \ (d \ne \mathbb{S} \longrightarrow \mathcal{A}\ s\ d = \mathcal{A}\ t\ d)
\end{align*}
\end{definition}

\subsubsection{Security Proofs}
To prove that the instantiated model is a security model, we have to prove the assumptions of the security model $\mathcal{S\_M}$. The first two assumptions are preserved by the interfering $\interf$ definition. The third assumption is preserved by the definition of equivalence for the \emph{scheduler} domain. The fourth assumption on the reachability is preserved by the relation $\varphi$ together with the following lemma:

To prove the last assumption \emph{integrity(e)}, we prove the definition of integrity for each event.

\begin{lemma} [Integrity of alloc\_memory]
\begin{align*}
\forall d\ s\ s'\ \Delta_s.\ &\mathcal{R}(s) \wedge (\xi\ s) \ninterf d\ \wedge\\
&s' = alloc\_memory\ s\ \Delta_s \longrightarrow \equidom{s}{d}{s'}
\end{align*}
\end{lemma}

\begin{lemma} [Integrity of free\_memory]
\begin{align*}
\forall d\ s\ s'\ b.\ &\mathcal{R}(s) \wedge (\xi\ s) \ninterf d\ \wedge\\
&s' = free\_memory\ s\ b \longrightarrow \equidom{s}{d}{s'}
\end{align*}
\end{lemma}

\begin{lemma} [Integrity of scheduler]
\begin{align*}
\forall d\ s\ s'.\ (\xi\ s) \ninterf d \longrightarrow \equidom{s}{d}{s'}
\end{align*}
\end{lemma}

In the end, we prove that the event specification based on the buddy allocation specification satisfies the integrity property and is really a security model. According to the instantiation of $\interf$, one partition domain (the \emph{scheduler} domain can interfere any partition domain) cannot influence the memory address spaces of other partition domains. The integrity of memory address spaces ensures that the allocation and deallocation algorithms are trustworthy and accurate.

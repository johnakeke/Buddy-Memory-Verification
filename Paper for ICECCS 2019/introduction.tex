\section{Introduction}
The correctness of applications and libraries of a system using dynamic memory allocation relies on properties the memory structures have to preserve. Errors in any stage of the development process of the memory management components, may break those properties, leading to critical issues in the rest of the system. Along the last decades, formal methods have been successfully applied to the verification of critical systems such as~\cite{reg_rushby, reg_luu}. To improve confidence on the reliability of a memory management, verification of functional correctness and security properties is applied from the top specification layers down to the implementation and the machine code.

Formal verification has been applied to different level of abstractions on memory management systems. For instance, the work in~\cite{reg_higham} formalizes an abstraction of the memory management as a sequence of write and read operations, and proves the sequential consistency over this abstraction. Also focusing on a high level of abstraction, the work in~\cite{reg_blazy} specifies the memory layout and the operations that manage the memory including alloc, free, load and store at both specification and implementation levels \mycomment{specification and implementation levels of the imperative language? It is not clear the meaning of this either. Do they provide a very abstract memory model for the language focusing on specifications written in that imperative language and a more detailed one in case they want to use the imperative language for modelling specifications close to the implementation?}. It defines an axiomatic reasoning framework, proving that the memory semantics satisfies such axiomatic rules  \mycomment{Two things here. First, you do not prove that the memory semantics satisfy  an axiomatic reasoning framework. The operational semantics tells you how a system changes, an axiomatic reasoning rule allows you to check if some predicate, in whatever format the rules specify, is true. So you are relating things that, as you put them, cannot be described. Second, and this is more subtle but also important. You are describing completeness of the inference system, i.e., it is possible to prove any possible predicate from the operational semantics, using some notion of validity, by using the reasoning rules. Interestingly you don't mention if the prove soundness of the proof system, i.e., any formula proven to be true using the proof system is indeed true according to some notion of validity in the operational semantics} . In a similar way,~\cite{reg_mansky} also provides an axiomatic proof system for a sequential memory model, which brings together an unified representation of the memory rules. In this sense, the work in~\cite{reg_mansky} proves that their memory rules also satisfy the ones in~\cite{reg_blazy}.

At the implementation level, the work from~\cite{reg_marti} specifies a heap manager from the implementation level directly and verified its functional correctness. It develops a library for separation logic to handle the pointers in C source codes and to ensure the separation of memory blocks. Another work \mycomment{Another work from this people? where is the first one? this is not well expressed}from~\cite{reg_mangano} specifies and verified a memory allocation module of Contiki \mycomment{what is Contiki? reference}, where blocks are preallocated \mycomment{why suddenly you give a isolated comment about the methodology without explaining what it means}. This work specifies the memory layouts using Frama-C, together with the allocation and deallocation operations. Its verification detects errors like out-of-bounds accesses and potentially harmful situations by using automatic provers like Frama-C/Wp \mycomment{Reference}. Also, the work from~\cite{reg_sahebolamri} formally verifies the correctness of a heap allocator at source code level. The C source code is translated into a model by using a specification language deep embedded in the Isabelle/HOL theorem prover~\cite{reg_Isabelle/HOL} using CParser and AutoCorres \mycomment{better to express it in the other way. They use the tools CParser and Autocorrect (better with references) to...}. A specification \mycomment{a specification of what? of the implementation of the heap allocator} consisting of allocation and deallocation operations \mycomment{this seems like the specification is written only in terms of allocation and deallocation operations} is built and formally proved. The equality \mycomment{you don't prove equality, you prove equivalence. They are obviously not equal so you cannot prove equality} between the implementation model and specification is also proved automatically.

\mycomment{start first describing the buddy system to then say that there are no work on its verification.} Although an extensive number of works have formally specified and verified the abstract models and implementations of dynamic memory allocation, little \mycomment{what is little work? is there or not? if there is not say there is not, if there is then mention it} work has been done to specify and verify buddy memory allocation. The buddy memory allocation system was originally described by~\cite{reg_knowlton}. It is widely used in many operating systems, in particular most versions of UNIX. For example, BSD~\cite{reg_mckusick} uses this memory system for blocks smaller than a page, i.e., 4 kilobytes. The classic description \mycomment{What do you mean with the classic description? why is THE classic, and why is it classic?} of the buddy memory allocation system is introduced in~\cite{reg_knuth}. \mycomment{if this is a standard, or simply, a description (perhaps the first description? if it is be sure that it is) then you should put it immediately after a brief introduction of the system, not just leave it to put it at the end. Write a connected story, not a number of unconnected facts.}

In this paper, we develop a specification for a buddy memory allocation algorithm in the Isabelle/HOL proof assistant. The specification provides applications with two services which are the allocation and disposal of memory blocks. Our specification consists of the algorithm details as specific as possible for the sake of capturing all features in the algorithm. Then we specify and prove properties including explicit behavior expectations and correct memory layouts for functional correctness of the specification. Finally, we show that the memory services preserve integrity of other memory blocks which have been previously allocated.

The paper is organized as follows. The second section briefly introduces the backgrounds of buddy memory allocation algorithms and Isabelle/HOL verification environment. Section three is about how we specify a buddy memory allocation model. The proofs to properties for functional correctness and the verification of integrity for security are arranged in section four. The last section is about the conclusions and future work.

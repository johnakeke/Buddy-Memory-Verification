\section{Introduction}
The correctness of applications and libraries of a system using dynamic memory allocation relies on properties the memory structures have to preserve. Errors in any stage of the development process of the memory management components, may break those properties, leading to critical issues in the rest of the system. Along the last decades, formal methods have been successfully applied to the verification of critical systems such as~\cite{reg_rushby, reg_luu}. To improve confidence on the reliability of a memory management, verification of functional correctness and security properties is applied from the top specification layers down to the implementation and the machine code.

Formal verification has been applied to different level of abstractions on memory management systems. For instance, the work in~\cite{reg_higham} formalizes an abstraction of the memory management as a sequence of write and read operations, and proves the sequential consistency over this abstraction. Also focusing on high level specification, the work in~\cite{reg_blazy} specifies the memory layout and the operations that manage the memory including alloc, free, load and store at two levels of abstraction. The abstract specification defines a general memory model for most of imperative languages, and proves properties such as block-valid before and after store operation. Then at concrete specification, it devotes to C-like languages (large subset of C) with pointer arithmetic. It implements the operations defined in the abstract specification, and proves that these operations satisfy the abstract specification. The properties which have been stated in the abstract specification are also proved in the concrete specification. In a similar way,~\cite{reg_mansky} provides an axiomatic specification for a sequential memory model. It offers allocation and free operations in the form of a set of axioms which characterize how well-behaved programs should be. Then it implements a sequential memory model with an LLVM-like language~\cite{reg_chris}. Finally, previous axioms are used to reason about the correctness of this implementation, and to prove it satisfies a well-behaved program.

At the implementation level, the work from~\cite{reg_marti} specifies a heap manager from the implementation level directly and verified its functional correctness. It develops a library for separation logic~\cite{reg_reynolds} to handle the pointers in C source codes and to ensure the separation of memory blocks. A work from~\cite{reg_mangano} specifies and verified a memory allocation module of Contiki~\cite{reg_dunkers}, a popular opensource operating system for IoT (Internet of Things). This work specifies the memory layouts using Frama-C~\cite{reg_kirchner}, together with the allocation and deallocation operations. Its verification detects errors like out-of-bounds accesses and potentially harmful situations by using automatic provers like Frama-C/Wp~\cite{reg_allan}. Also, the work from~\cite{reg_sahebolamri} formally verifies the correctness of a heap allocator at C source code level. They use the tools CParser and AutoCorres to translate the C source code into an implementation model in the Isabelle/HOL theorem prover~\cite{reg_Isabelle/HOL}. Then, they defines an abstract specification of this heap allocator, consisting memory layout, as well as allocation, free and initialization operations. This specification is formally proved and promised correctly. Finally, the equivalence between the implementation model and specification is proved automatically.

Although an extensive number of works have formally specified and verified the abstract models and implementations of dynamic memory allocation, no work has been done to specify and verify buddy memory allocation. The buddy memory allocation system was originally described by~\cite{reg_knowlton}. It mainly adopts the way of blocks being powered of two in size. This method makes it easy to check whether a deallocated block can be merged with an adjacent (free) block, using bit operations on the block addresses. Because of merging operation on two adjacent free blocks, it reduces the fragmentation. This memory allocation system is widely used in many operating systems, in particular most versions of UNIX. For example, BSD~\cite{reg_mckusick} uses this memory system for blocks smaller than a page, i.e., 4 kilobytes.

In this paper, we develop a specification for a buddy memory allocation algorithm in the Isabelle/HOL proof assistant. The specification provides applications with two services which are the allocation and disposal of memory blocks. Our specification consists of the algorithm details as specific as possible for the sake of capturing all features in the algorithm. Then we specify and prove properties including explicit behavior expectations and correct memory layouts for functional correctness of the specification. Finally, we show that the memory services preserve integrity of other memory blocks which have been previously allocated.

The paper is organized as follows. The second section briefly introduces the backgrounds of buddy memory allocation algorithms and Isabelle/HOL verification environment. Section three is about how we specify a buddy memory allocation model. The proofs to properties for functional correctness and the verification of integrity for security are arranged in section four. The last section is about the conclusions and future work.

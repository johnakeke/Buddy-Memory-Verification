\section{Introduction}
Correctness of applications and libraries of a system using dynamic memory allocation relies on properties the memory have to preserve. Errors in any stage of the development process of the memory management component, may break those properties, leading to critical issues in the rest of the system. Along the last decades, formal methods have been successfully applied in the verification of critical systems. To improve confidence on the reliability of a memory management, verification of functional correctness and security properties is applied from the top specification layers down to the implementation and the machine code.

Formal verification has been applied on memory managers going from very abstract models to more concrete ones. For instance, the work in~\cite{reg_higham} formalizes an abstraction of the memory management in term of write and read operations. They prove sequential consistency over the abstraction, so the memory is expressed as ordered sequence of reads and writes. Also focusing on a high level of abstraction, the work in~\cite{reg_blazy} provides a memory model for an imperative language, defining the necessary memory operations for the language at the specification and implementation levels. It defines an axiomatic reasoning framework, proving that the memory semantics satisfy such axiomatic rules. In a similar way~\cite{reg_mansky}, also provides an axiomatic proof system for a sequential memory model, bringing together an unified representation of the memory rules. In this sense, the work in~\cite{reg_mansky} proves that their memory rules also satisfy the ones in~\cite{reg_blazy}.

For concrete managers, the work from~\cite{reg_marti} specifies a heap manager from the implementation level directly and verifies its functional correctness. It develops a library for separation logic to handle the pointers in C source codes and to ensure the separation of memory blocks. Another work from~\cite{reg_mangano} specifies and verifies a memory allocation module of Contiki, where blocks are preallocated. The work specifies C source codes by Frama-C in memory structure and allocation and deallocation operations. Its verification detects errors like out-of-bounds accesses and potentially harmful situations by automatic provers like Frama-C/Wp. Also, work from~\cite{reg_sahebolamri} formally verifies the correctness of a heap allocator at the source code level. The C source codes are translated into semantics language in Isabelle/HOL using CParser and AutoCorres. A specification consists of allocation and deallocation operations is built and formally proved. The equality between semantics language and specification is also proved automatically.

In this paper, we develop a specification for buddy allocation algorithms in the Isabelle/HOL proof assistant. The buddy allocation algorithms provide to applications with two services for the allocation and disposal of memory blocks. Our specification consists of algorithm details as specific as possible for the sake of capturing any feature in the algorithms. Then we specify and prove a number of properties for functional correctness of the algorithm. Finally, we show that the memory services preserve integrity of other memory areas previously allocated.

The following section briefly introduces the background of Isabelle/HOL verification environment and buddy allocation algorithms. The next section is about the formalization of buddy allocation model including representation of our specification and proofs to properties for functional correctness. The verification of integrity for security is arranged in the following section. The last section is about the conclusions and future work.

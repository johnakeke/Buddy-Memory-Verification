\section{Introduction}
The correctness of applications and libraries of a system using dynamic memory allocation relies on properties the memory has to preserve. Errors in any stage of the development process of the memory management components, may break those properties, leading to critical issues in the rest of the system. Along the last decades, formal methods have been successfully applied to the verification of critical systems. To improve confidence on the reliability of a memory management, verification of functional correctness and security properties is applied from the top specification layers down to the implementation and the machine code.

Formal verification has been applied to memory managers going from very abstract models to more concrete ones. For instance, the work in~\cite{reg_higham} formalized an abstraction of the memory management by a sequence of write and read operations. They proved the sequential consistency over this abstraction. Also focusing on a high level of abstraction, the work in~\cite{reg_blazy} provided a memory model for an imperative language, defining the necessary memory operations for the language at both specification and implementation levels. It defined an axiomatic reasoning framework, proving that the memory semantics satisfies such axiomatic rules. In a similar way,~\cite{reg_mansky} also provided an axiomatic proof system for a sequential memory model, which brings together an unified representation of the memory rules. In this sense, the work in~\cite{reg_mansky} proved that their memory rules also satisfy the ones in~\cite{reg_blazy}.

For the implementation level, the work from~\cite{reg_marti} specified a heap manager from the implementation level directly and verified its functional correctness. It developed a library for separation logic to handle the pointers in C source codes and to ensure the separation of memory blocks. Another work from~\cite{reg_mangano} specified and verified a memory allocation module of Contiki, where blocks are preallocated. The work specified C source codes of memory layouts, allocation and deallocation operations by Frama-C. Its verification detected errors like out-of-bounds accesses and potentially harmful situations by automatic provers like Frama-C/Wp. Also, work from~\cite{reg_sahebolamri} formally verified the correctness of a heap allocator at source code level. The C source codes were translated into semantics language in Isabelle/HOL using CParser and AutoCorres. A specification consisting of allocation and deallocation operations was built and formally proved. The equality between semantics language and specification was also proved automatically.

Although an extensive number of works have formally specified and verified the abstract models and implementations of dynamic memory allocation, to our knowledge, litter work has been done to specify and verify buddy memory allocation. Our work is then such a work that to specify and verify the buddy memory allocation in algorithms level. The buddy memory allocation system was originally described by~\cite{reg_knowlton}. It is widely used in many operating systems, in particular most versions of UNIX. For example, BSD~\cite{reg_mckusick} uses this memory system for blocks smaller than a page, i.e., 4 kilobytes. The classic description of the buddy memory allocation system is released by~\cite{reg_knuth}.

In this paper, we develop a specification for a buddy memory allocation algorithm in the Isabelle/HOL proof assistant. The algorithm provides applications with two services which are the allocation and disposal of memory blocks. Our specification consists of algorithm details as specific as possible for the sake of capturing all features in the algorithm. Then we specify and prove properties including explicit behavior expectations and correct memory layouts for functional correctness of the algorithm. Finally, we show that the memory services preserve integrity of other memory blocks which are previously allocated.

The paper is organized as follows. The second section briefly introduces the backgrounds of buddy memory allocation algorithms and Isabelle/HOL verification environment. The next section is about how we specify a buddy memory allocation model. The proofs to properties for functional correctness and the verification of integrity for security are arranged in the following section. The last section is about the conclusions and future work.

\section{Introduction}
The correctness of applications and libraries of a system using dynamic memory allocation relies on properties the memory has to preserve. Errors in any stage of the development process of the memory management components, may break those properties, leading to critical issues in the rest of the system. Along the last decades, formal methods have been successfully applied to the verification of critical systems. To improve confidence on the reliability of a memory management, verification of functional correctness and security properties is applied from the top specification layers down to the implementation and the machine code.

Formal verification has been applied to memory managers going from very abstract models to more concrete ones. For instance, the work in~\cite{reg_higham} formalized an abstraction of the memory management by a sequence of write and read operations. They proved the sequential consistency over the abstraction. Also focusing on a high level of abstraction, the work in~\cite{reg_blazy} provided a memory model for an imperative language, defining the necessary memory operations for the language at both specification and implementation levels. It defined an axiomatic reasoning framework, proving that the memory semantics satisfies such axiomatic rules. In a similar way,~\cite{reg_mansky} also provided an axiomatic proof system for a sequential memory model, which brings together an unified representation of the memory rules. In this sense, the work in~\cite{reg_mansky} proved that their memory rules also satisfy the ones in~\cite{reg_blazy}.

For the implementation level, the work from~\cite{reg_marti} specified a heap manager from the implementation level directly and verified its functional correctness. It developed a library for separation logic to handle the pointers in C source codes and to ensure the separation of memory blocks. Another work from~\cite{reg_mangano} specified and verified a memory allocation module of Contiki, where blocks are preallocated. The work specified C source codes of memory layouts, allocation and deallocation operations by Frama-C. Its verification detected errors like out-of-bounds accesses and potentially harmful situations by automatic provers like Frama-C/Wp. Also, work from~\cite{reg_sahebolamri} formally verified the correctness of a heap allocator at source code level. The C source codes are translated into semantics language in Isabelle/HOL using CParser and AutoCorres. A specification consisting of allocation and deallocation operations was built and formally proved. The equality between semantics language and specification was also proved automatically.

In this paper, we develop a specification for a buddy allocation algorithm in the Isabelle/HOL proof assistant. The algorithm provides two services for the allocation and disposal of memory blocks to applications. Our specification consists of algorithm details as specific as possible for the sake of capturing all features in the algorithm. Then we specify and prove properties including explicit behavior expectations and correct memory layouts for functional correctness of the algorithm. Finally, we show that the memory services preserve integrity of other memory blocks previously allocated.

The following of the paper is organized as follows. The second section briefly introduces the background of buddy allocation algorithms and Isabelle/HOL verification environment. The next section is about how we specify a buddy allocation model. The proofs to properties for functional correctness and the verification of integrity for security are arranged in the following section. The last section is about the conclusions and future work.

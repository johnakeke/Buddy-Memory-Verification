\section{Introduction}
The correctness of applications and libraries of a system using dynamic memory allocation relies on properties the memory structures have to preserve. Errors at any stage of the development process of the memory management components, may break those properties, leading to critical issues in the rest of the system. Along the last decades, formal methods have been successfully applied to the verification of critical systems such as~\cite{reg_rushby, reg_luu}. To improve confidence on the reliability of a memory management, verification of functional correctness and security properties is applied from the top specification layers down to the implementation and the machine code.

Formal verification has been applied to different level of abstractions on memory management systems. For instance, the work in~\cite{reg_higham} formalizes an abstraction of the memory management as a sequence of write and read operations, and proves the sequential consistency over this abstraction. Also focusing on high level specification, the work in~\cite{reg_blazy} specifies the memory layout and the operations that manage the memory including alloc, free, load and store at two levels of abstraction. The abstract specification defines a general memory model for most of imperative languages, and proves properties such as block-valid before and after a store operation. Then at the concrete specification, it focusses on a C-like language (large subset of C) with pointer arithmetic. It implements the operations defined in the abstract specification, and proves that these operations satisfy the abstract specification. The properties which have been stated in the abstract specification are also proved in the concrete specification. In a similar way,~\cite{reg_mansky} provides an axiomatic specification for a sequential memory model. It offers allocation and free operations in the form of a set of axioms which characterize well-behaved programs. Then it implements a sequential memory model with an LLVM-like language~\cite{reg_chris}. Finally, the axioms on  well-behaved programs are used to reason about the correctness of this implementation, and to prove it satisfies a well-behaved program.

At the implementation level, the work from~\cite{reg_marti} specifies a heap manager modelling the implementation details and verifies its functional correctness. It develops a library for separation logic~\cite{reg_reynolds} to handle pointers in the C source code and to ensure the separation of memory blocks. The work from~\cite{reg_mangano} specifies and verifies the memory allocation module of Contiki~\cite{reg_dunkers}, a popular open source operating system for IoT (Internet of Things). This work specifies the memory layout using Frama-C~\cite{reg_kirchner}, together with the allocation and deallocation operations. Its verification detects errors like out-of-bounds accesses and potentially harmful situations by using automatic provers like Frama-C/Wp~\cite{reg_allan}. Also, the work from~\cite{reg_sahebolamri} formally verifies the correctness of a heap allocator at the C source code level, consisting of the memory layout, and the allocation, free and initialization operations. They use the tools CParser~\cite{reg_tuch} and AutoCorres~\cite{reg_greenaway} to translate the C source code into an implementation model in the Isabelle/HOL theorem prover~\cite{reg_Isabelle/HOL}.

Although an extensive number of works have formally specified and verified abstract models and implementations for dynamic memory allocation systems, up to our knowledge no work has been done to specify and verify buddy memory allocation. The buddy memory allocation system was originally described by~\cite{reg_knowlton}. The buddy systems organize the memory in layers with a power of two number of nodes, which are buddies one of each other. Free memory blocks are split during allocation to adequate the requested amount of memory to their size, and hence reduce the external fragmentation. During deallocation of a memory block, a set of non-allocated buddies are merged into a block belonging to an upper layer. This memory allocation system is widely used in many operating systems. For example, BSD~\cite{reg_mckusick} uses this memory system for blocks smaller than a page, i.e., 4 kilobytes.

In this paper, we develop a specification for a buddy memory allocation algorithm in the Isabelle/HOL proof assistant. The specification provides applications with services for allocation and disposal of memory blocks, which completely captures the behaviour of the algorithms. Then we specify and prove properties  over the memory layout to achieve functional correctness of the specification. Finally, we show that the memory services preserve integrity of other memory blocks which have been previously allocated.

The paper is organized as follows. The second section briefly introduces the backgrounds of buddy memory allocation algorithms and Isabelle/HOL verification environment. Section three is about how we specify a buddy memory allocation model. The proofs to properties for functional correctness and the verification of integrity for security are arranged in section four. The last section is about the conclusions and future work.

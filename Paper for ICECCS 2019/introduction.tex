\section{Introduction}
The correctness of applications and libraries of a system using dynamic memory allocation relies on properties the memory structures have to preserve. Errors in any stage of the development process of the memory management components, may break those properties, leading to critical issues in the rest of the system. Along the last decades, formal methods have been successfully applied to the verification of critical systems  \mycomment{references?}. To improve confidence on the reliability of a memory management, verification of functional correctness and security properties is applied from the top specification layers down to the implementation and the machine code \mycomment{\textit{is applied?} that means that indeed there are existing works doing this. If there is add references here, if there is not rephrase this to say exactly what you want to say}.

Formal verification has been applied to memory managers going from very abstract models to more concrete ones \mycomment{this seems to say the same than you have written in the line above, but with different words. Please avoid repetition. Perhaps you mean that Formal verification has been applied to different level of abstractions on memory managers. If you immediately say from very abstract models to more concrete ones may be interpreted as if it is has been applied to the same system}. For instance, the work in~\cite{reg_higham} \mycomment{use present} \correct{formalized}{formalizes} an abstraction of the memory management \correct{by}{as} a sequence of write and read operations. They \mycomment{use present} proved the sequential consistency over this abstraction \mycomment{avoid this kind of abrupt short sentences, link it to the previous sentence with an and, or a comma and gerund}. Also focusing on a high level of abstraction, the work in~\cite{reg_blazy} \mycomment{use present}  provided a memory model for an imperative language, defining the necessary memory operations for the language  \mycomment{what does defining the memory operations for the language mean? This is the kind of things I always ask you to read and see if someone who is not you would be able to understand.} at both specification and implementation levels \mycomment{specification and implementation levels of the imperative language? It is not clear the meaning of this either. Do they provide a very abstract memory model for the language focusing on specifications written in that imperative language and a more detailed one in case they want to use the imperative language for modelling specifications close to the implementation?}. It \mycomment{use present} defined an axiomatic reasoning framework, proving that the memory semantics satisfies such axiomatic rules  \mycomment{Two things here. First, you do not prove that the memory semantics satisfy  an axiomatic reasoning framework. The operational semantics tells you how a system changes, an axiomatic reasoning rule allows you to check if some predicate, in whatever format the rules specify, is true. So you are relating things that, as you put them, cannot be described. Second, and this is more subtle but also important. You are describing completeness of the inference system, i.e., it is possible to prove any possible predicate from the operational semantics, using some notion of validity, by using the reasoning rules. Interestingly you don't mention if the prove soundness of the proof system, i.e., any formula proven to be true using the proof system is indeed true according to some notion of validity in the operational semantics} . In a similar way,~\cite{reg_mansky} also \mycomment{use present} provided an axiomatic proof system for a sequential memory model, which brings together an unified representation of the memory rules. In this sense, the work in~\cite{reg_mansky} \mycomment{use present}  proved that their memory rules also satisfy the ones in~\cite{reg_blazy}.

\correct{For}{At} the implementation level, the work from~\cite{reg_marti} \mycomment{use present} specified a heap manager from the implementation level directly and verified its functional correctness. It \mycomment{use present} developed a library for separation logic to handle the pointers in C source codes and to ensure the separation of memory blocks. Another work \mycomment{Another work from this people? where is the first one? this is not well expressed}from~\cite{reg_mangano} \mycomment{use present} specified and verified a memory allocation module of Contiki \mycomment{what is Contiki? reference}, where blocks are preallocated \mycomment{why suddenly you give a isolated comment about the methodology without explaining what it means}. \correct{The work specified C source codes of memory layouts, allocation and deallocation operations by Frama-C}{This work specifies using Frama-C the memory layout, together with the allocation and deallocation operations}. Its verification \mycomment{use present} detected errors like out-of-bounds accesses and potentially harmful situations \correct{by}{by using}\mycomment{or simply using} automatic provers like Frama-C/Wp \mycomment{Reference}. Also, \correct{}{the} work from~\cite{reg_sahebolamri} formally \mycomment{use present} verified the correctness of a heap allocator at source code level. The C source code\correct{s}{} \correct{were}{is} translated into \correct{semantics language in Isabelle/HOL}{a model by using a specification language deep embedded in the Isabelle/HOL theorem prover} \mycomment{reference for Isabelle HOL} using CParser and AutoCorres \mycomment{better to express it in the other way. They use the tools CParser and Autocorrect (better with references) to...}. A specification \mycomment{a specification of what? of the implementation of the heap allocator} consisting of allocation and deallocation operations \mycomment{this seems like the specification is written only in terms of allocation and deallocation operations} \mycomment{use present} was built and formally proved. The equality \mycomment{you don't prove equality, you prove equivalence. They are obviously not equal so you cannot prove equality} between \correct{semantics language}{the implementation model} and specification was also \mycomment{use present} proved automatically .

\mycomment{start first describing the buddy system to then say that there are no work on its verification.} Although an extensive number of works have formally specified and verified the abstract models and implementations of dynamic memory allocation, to our knowledge, \correct{litter}{little} \mycomment{to litter is to throw rubbish} \mycomment{what is little work? is there or not? if there is not say there is not, if there is then mention it} work has been done to specify and verify buddy memory allocation. \correct{Our work is then such a work that to}{This is really a very bad expression please, rewrite using a simply and direct language} specify and verify the buddy memory allocation in algorithms level. The buddy memory allocation system was originally described by~\cite{reg_knowlton}. It is widely used in many operating systems, in particular most versions of UNIX. For example, BSD~\cite{reg_mckusick} uses this memory system for blocks smaller than a page, i.e., 4 kilobytes. The classic description \mycomment{What do you mean with the classic description? why is THE classic, and why is it classic?} of the buddy memory allocation system is \correct{released}{introduced} in~\cite{reg_knuth}. \mycomment{if this is a standard, or simply, a description (perhaps the first description? if it is be sure that it is) then you should put it immediately after a brief introduction of the system, not just leave it to put it at the end. Write a connected story, not a number of unconnected facts.}

\mycomment{You already said something similar above. Avoid repetitions, read the text and see where is the best place to add what you want to tell. Only repeat things when you briefly want to remind things that were explained somewhere else far from where you are at the moment (perhaps you mentioned something in the background that it is important to highlight 10 pages after it).}In this paper, we develop a specification for a buddy memory allocation algorithm in the Isabelle/HOL proof assistant. The algorithm provides applications with two services which are the allocation and disposal of memory blocks \mycomment{an algorithm does not provide nothing to applications}. Our specification consists of \correct{}{the} algorithm details as specific as possible for the sake of capturing all features in the algorithm. Then we specify and prove properties including explicit behavior expectations and correct memory layouts for functional correctness of the algorithm. Finally, we show that the memory services preserve integrity of other memory blocks which have been previously allocated.

The paper is organized as follows. The second section briefly introduces the backgrounds of buddy memory allocation algorithms and \correct{the} Isabelle/HOL verification environment. The next section is about how we specify a buddy memory allocation model. The proofs to properties for functional correctness and the verification of integrity for security are arranged in the following section\mycomment{next, following to... also poorly written, improve that. try to use about less, you are not telling a tale}. The last section is about the conclusions and future work.

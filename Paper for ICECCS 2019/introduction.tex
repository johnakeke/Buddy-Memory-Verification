\section{Introduction}
The correctness of applications and libraries of a system using dynamic memory allocation relies on properties the memory structures have to preserve. Errors at any stage of the development process of the memory management components may break those properties, leading to critical issues in the rest of the system. Along the last decades, formal methods have been successfully applied to the verification of critical systems such as~\cite{reg_rushby, reg_luu}. To improve confidence on the reliability of a system, functional correctness and security properties are verified from the top specification layers down to the implementation and the machine code.

Formal verification has been carried out to different levels of abstraction on memory management systems. For instance, the work in~\cite{reg_higham} formalizes an abstraction of the memory management as a sequence of write and read operations, and proves sequential consistency over this abstraction. Also focusing on a high level specification, the work in~\cite{reg_blazy} specifies the memory layouts and the alloc, free, load and store operations at two levels of abstraction. An abstract specification defines a general memory model for imperative languages, and proves properties such as block validity before and after a store operation. Then a more concrete specification focuses on a C-like language (a large subset of C) with pointer arithmetic. It implements the operations defined in the abstract specification, and proves that the operations satisfy properties specified in the abstract specification. In a similar way,~\cite{reg_mansky} provides an axiomatic specification of the allocation and free operations for a sequential memory model characterizing well behaved programs. It then implements a sequential memory model with an LLVM-like language~\cite{reg_chris}. Finally, the axioms on well-behaved programs are used to reason about the correctness of the implementation, and to prove it satisfies a well-behaved program.

At the implementation level, the work from~\cite{reg_marti} specifies a heap manager modeling low-level implementation details and verifies its functional correctness. It develops a library for separation logic~\cite{reg_reynolds} to handle pointers in the C source code and to ensure the separation of memory blocks. The work from~\cite{reg_mangano} specifies and verifies the memory allocation module of Contiki~\cite{reg_dunkers}, a popular open source operating system for IoT (Internet of Things). This work specifies the memory layouts using Frama-C~\cite{reg_kirchner}, together with the allocation and deallocation operations. Its verification detects errors like out-of-bounds accesses and potentially harmful situations by using automatic provers like Frama-C/Wp~\cite{reg_allan}. Also, the work from~\cite{reg_sahebolamri} formally verifies the correctness of a heap allocator at the C source code level, consisting of the memory layouts, and the allocation, free and initialization operations. They use the tools CParser~\cite{reg_tuch} and AutoCorres~\cite{reg_greenaway} to translate the C source code into an implementation model in the Isabelle/HOL theorem prover~\cite{reg_Isabelle/HOL}.

Although an extensive number of works have formally specified and verified abstract models and implementations for dynamic memory allocation systems, up to our knowledge no work has been done to specify and verify buddy memory allocation. Originally described by~\cite{reg_knowlton}, a buddy memory allocation organizes the memory in logical layers, in which children of the same logical node are \emph{buddies} of each other. Free memory blocks are split during allocation to adequate the requested amount of memory to their size, and hence reduce the external fragmentation. During deallocation of a memory block, a set of free buddy memory blocks are merged into a free block, that belongs to an upper logical layer. This memory allocation system is widely used in many operating systems. For example, BSD~\cite{reg_mckusick} uses this memory system for blocks smaller than a page, i.e., 4 kilobytes. The Zephyr OS~\cite{reg_zephyr}, a micro-kernel from the Linux Foundation focusing on IoT devices, also uses this memory system.

As a first step to achieve the correctness of a buddy memory management, we develop and verify a specification for a buddy memory algorithm. The specification provides applications with services for allocation and disposal of memory blocks, which completely captures the behavior of the algorithm. Then we specify and prove properties over the memory layouts to achieve functional correctness of the operations and invariants related to the memory logical layouts. Finally, we show that the memory services preserve the integrity of other previously allocated memory blocks. The specification and proofs have been carried out in the Isabelle/HOL proof assistant and it is composed of about 5000 lines of specifications and proofs. The interested reader can access the models and proofs at~\footnote{http://securify.sce.ntu.edu.sg/buddy.zip}.

The paper is organized as follows. The second section provides a background on the buddy memory allocation algorithms and the Isabelle/HOL verification environment. Section 3 describes the buddy memory allocation model. The proofs to properties for functional correctness and the verification of integrity for security are arranged in section 4. The last section we give the conclusions and future work.

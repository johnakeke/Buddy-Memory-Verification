\begin{figure*}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{fig1.pdf}
	\caption{The progress of dividing a free leaf}
	\label{fig:splitleaf}
\end{figure*}

\section{Specification of Buddy Allocation Model}\label{sec:spec}
The specification of the buddy memory allocation consists of a model for the necessary data structures to represent the memory layout, as well as a model for the allocation and disposal operations. This specification follows the algorithm for the buddy memory management in Zephyr OS, which applies a quartering split over blocks.

\subsection{State Representation}\label{statedes}
In the specification, the state models the memory as a set of quad-trees, each of them representing a memory pool. At this level of the specification, we assume that applications work with our block entity, so requesting a memory block returns the block itself, which will be used later during the deallocation.
\begin{align*}
(set:\ 'a)\ tree\ =\ &Leaf\ (L:\ 'a)\ | \\
&Node\ (LL:\ 'a\ tree)\ (LR:\ 'a\ tree)\\
&\ \ \ \ \ \ \ \ (RL:\ 'a\ tree)\ (RR:\ 'a\ tree)
\end{align*}

We define the structure of a quad-tree inductively. A quad-tree is parametrized by a variable type $'a$ and it has two constructors: \emph{Leaf} and \emph{Node}. A \emph{Leaf} is a terminal node storing values of the parametrized type $'a$, and a \emph{Node} has four (sub)trees that are built recursively. Notations \emph{LL}, \emph{LR}, \emph{RL} and \emph{RR} return the corresponding subtrees of the \emph{Node} tree. The notation \textbf{set} represents a function that gathers values of the parametrized type $'a$ from all \emph{Leaf} nodes.

In this specification, we use the tuple (\emph{block\_state\_type} $\times$ \emph{ID}) to instantiate the polymorphic type \emph{'a} in the quad-tree structure. Type \emph{block\_state\_type} indicates the usage state of a block and it is constructed using an Isabelle/HOL \emph{datatype}. It consists of two subtypes: \emph{ALLOC} and \emph{FREE}. The former is used to mark memory blocks that have been allocated to applications, whilst the latter is used to mark those unallocated blocks (hence they are free to be assigned to applications requesting memory). The type \emph{ID} is a natural number representing the address identifier of a memory block. Finally, the type \emph{BlockTree} represents an instantiated quad-tree in which terminal nodes represent allocated or free memory blocks identified by a natural number. We will indistinctively use the term of \emph{Leaf} as memory block along the document.
\begin{align*}
block\_state\_type\ &=\ FREE\ |\ ALLOC \\
ID\ &=\ nat \\
BlockTree\ &=\ (block\_state\_type\ \times\ ID)\ tree
\end{align*}

The allocation and free services are defined as a number of operations over the \emph{quad-tree} data structure representing the memory. These operations manipulate a \textsl{BlockTree}, accessing and modifying its structure and the data it stores. The function \textbf{level} takes two \emph{BlockTree}: \emph{btree} and \emph{b}, and it returns a natural number that represents the layer number where \emph{b} is located in \emph{btree} from the root node. The level of a node with regards to itself is $0$, and if $b$ does not belongs to $btree$, the function also returns $0$. We use the definitions \textbf{free\_lvl} and \textbf{alloc\_lvl}, which take a \emph{Blocktree} \emph{btree} and a natural number $l$, to respectively obtain the set with all the free and allocated \emph{Leaf} nodes located at level $l$ in \emph{btree}. We use the notation \emph{idset} to represent the collection of all used \emph{IDs}. To create a new Leaf node, we pick up as new \emph{ID} any natural number not belonging to \emph{idset}.

\subsection{Allocation Model}

\begin{definition} [Allocation Operation]
\begin{flalign*}
&alloc\ bset\ \Delta_s \triangleq \\
&if\ exists\_freelevel\ bset\ \Delta_s\ then \\
&\ \ \ \ lmax = freesets\_ml\ bset\ \Delta_s \\
&\ \ \ \ btree = SOME\ b.\ b \in bset \wedge free\_lvl\ b\ \Delta_s \ne \emptyset \\
&\ \ \ \ le = SOME\ l.\ l \in free\_lvl\ btree\ \Delta_s \\
&\ \ \ \ if\ lmax = \Delta_s\ then \\
&\ \ \ \ \ \ \ \ btree' = replace\ btree\ le\ (set\_type\ le\ ALLOC) \\
&\ \ \ \ \ \ \ \ return\ (bset - \lbrace btree \rbrace \cup \lbrace btree' \rbrace,\ True) \\
&\ \ \ \ else \\
&\ \ \ \ \ \ \ \ btree' = replace\ btree\ le\ (split\ le\ (\Delta_s - lmax)) \\
&\ \ \ \ \ \ \ \ return\ (bset - \lbrace btree \rbrace \cup \lbrace btree' \rbrace,\ True) \\
&else\ return\ (bset,\ False)
\end{flalign*}
\end{definition}

The allocation takes as input a set of quad-trees representing the available memory pools $bset$, and a natural number $s$ representing the requested size of the memory to allocate. If $s$ is bigger than the maximum size $\Omega$ for any memory pool, then the allocation fails and the state is not modified. If $s$ is smaller or equal than $\Omega$, then it calls function \textbf{alloc} over $bset$ and the level $\Delta_s$ containing blocks of size bigger or equal to $s$, as defined in Section~\ref{sec:buddy}. Function \textbf{alloc} carries out the necessary operations to find a block of size bigger or equal than $s$, and conducts the necessary modifications on $bset$ as we describe below.

\begin{figure*}[htbp]
\centering
\includegraphics[width=0.7\textwidth]{fig2.pdf}
\caption{The progress of merging all free memory blocks}
\label{fig:merginfreeblocks}
\end{figure*}

%Alloc uses the predicate \textbf{exists\_freelevel}, with parameters $bset$ and $rlv$, to check if there exists a \emph{BlockTree} $b \in bsets$ and a level $l\leq rlv$ in $b$ such that $l$ has at least a free node.  and \textbf{freesets\_ml}. We first provide a description of these functions. Function \textbf{freesets\_ml} has the same inputs, and it returns the maximum level less or equal than $rlv$ for which it sets of free levels is not empty. Formally:
%
%\begin{definition} [Existence of Free Leaf Nodes]
%\begin{align*}
%exists&\_freelevel\ bset\ rlv \triangleq \\
%&\exists l\ b.\ l \leq rlv\ \wedge b \in bset \wedge free\_lvl\ b\ l \ne \emptyset
%\end{align*}
%\end{definition}
%
%\begin{definition} [Maximum Level of Free Leaf Nodes]
%\begin{align*}
%free&sets\_maxlevel\ bset\ rlv \triangleq THE\ lmax.\\
%&lmax \leq rlv\ \wedge \exists b \in bset.\ free\_lvl\ b\ lmax \neq \emptyset\ \wedge\\
%&(\forall l \leq rlv.\ \exists b \in bset.\ free\_lvl\ b\ l \ne \emptyset \longrightarrow \\
%&\ \ \ l \leq lmax)
%\end{align*}
%\end{definition}

%In addition, the allocation uses functions \textbf{set\_type}, \textbf{replace} and \textbf{replace\_leaf}. Function \emph{set\_type} takes a Leaf node \emph{b} and a target \emph{block\_state\_type} \emph{s} as inputs, and returns a leaf \emph{b'} resulting of changing the state of \emph{b} to \emph{s}. Function \emph{replace} takes a \emph{BlockTree} \emph{btree}, two Leaf nodes \emph{b} and \emph{b'} as inputs, and returns a tree replacing the Leaf node \emph{b} with \emph{b'} in \emph{btree}. Function \emph{replace\_leaf} takes a \emph{BlockTree} \emph{btree}, a Leaf node \emph{b} and a Node tree \emph{btr} as inputs, and returns the tree that replaces the Leaf node \emph{b} with \emph{btr} in \emph{btree}.

To allocate a block of size $s$ as described in Section~\ref{sec:buddy}, \textbf{alloc} firstly uses the predicate \textbf{exists\_freelevel}, which takes as input a set of \emph{BlockTree} $bset$ and the requested level $\Delta_s$ as parameters. \textbf{exists\_freelevel} checks whether there is a \emph{BlockTree} in \emph{bset} with free blocks at a level $l \leq \Delta_s$. If there is not, then the allocation process fails and returns the initial \emph{bset}. Otherwise, the function \textbf{freesets\_ml} takes $bset$ and $\Delta_s$ to return the maximum level $lmax \leq \Delta_s$ in $bset$ containing free blocks. The allocation procedure then gets a \emph{BlockTree} $btree$ from $bset$ such that there are free blocks at level $lmax$ and it randomly picks up a free \emph{Leaf} node $le$ from $btree$ at the level $lmax$. From here there are two options:

(1) There is a \emph{BlockTree} with free nodes at the requested level. Thence $lmax$ is equal to the requested level $\Delta_s$, and blocks at level $lmax$ have the minimum size to allocate the requested amount of memory. In this case the splitting process is not necessary and the procedure simply sets the type of $le$ as \emph{ALLOC} in $btree$, using the functions \textbf{set\_type} and \textbf{replace}, to obtain a new \emph{BlockTree} $btree'$. After that, the allocation returns an updated $bset$ by replacing the previous $btree$ with $btree'$. Note that this execution branch does not add any additional node into the tree structure, and only modifies the type of a terminal node at level $\Delta_s$.

(2) There is not a \emph{BlockTree} with free nodes at the requested level, and hence $lmax$ is smaller to the requested level $\Delta_s$. During the allocation process, if there is not any free \emph{Leaf} node available at the best fit level $\Delta_s$ for the requested size, but there exists a higher level $hl$ in the tree structure, hence $hl < \Delta_s$, with free blocks, it is necessary to start the splitting process from $hl$ down to $\Delta_s$. Fig.~\ref{fig:splitleaf} describes this process. The function \textbf{split} recursively divides a \emph{Leaf} node \emph{b} into a \emph{Node} tree \emph{btree} for $l - hl$ times. It uses the function \textbf{divide} that takes a Leaf node \emph{b} and returns a new non-terminal \emph{Node} tree \emph{n} with four terminal \emph{Leaf} nodes. The division operation is always conducted on the leftmost subtree of $n$ marking it as \emph{ALLOC}, while the rest are marked as \emph{FREE}. Therefore, the allocation replaces $le$ in $btree$ with the resulting node of splitting $le$ as described, following the rest of the procedure as in the first case. We define the \emph{split} operation as follows.

\begin{definition} [Split a Leaf Node]
\begin{align*}
split\ b\ lv &\triangleq\ if\ lv = 0\ then\ b\ else\\
Node\ &(split\ (LL\ divide\ b)\ (lv - 1))\ (LR\ divide\ b)\\ 
&(RL\ divide\ b)\ (RR\ divide\ b)
\end{align*}
\end{definition}

Note that \textbf{alloc} modifies a free block into an allocated one, so the number of leaves remain unmodified in the branch; or breaks a free block into a \emph{Node} tree to eventually create a number of free blocks and an allocated block as shown in Fig.~\ref{fig:splitleaf}. In both cases the rest of Leaves from the original set do not change and there is a new allocated block that was not contained in the set of allocated blocks of the initial tree. To obtain the block \textbf{alloc} allocates, it is only necessary to subtract the allocated nodes in the original set of free nodes from the allocated nodes in the resulting set.

\subsection{Deallocation Model}
The deallocation process takes a \emph{Leaf} node $b$ and a set of \emph{BlockTree} $bset$, and sets the state of $b$ to \emph{FREE}. During the deallocation process, if the state of all the buddies of $b$ is already $free$ and the level $l$ of $b$ is not the root node, the buddy nodes are merged to avoid fragmentation. The merging process is shown in Fig.~\ref{fig:merginfreeblocks}. During the merging process, $b$ and its buddies are removed, and the parent \emph{Node} of $b$ is transformed into a \emph{Leaf} node at level $l - 1$ that is set as free.

The function \textbf{free} firstly checks whether there is a $btree \in bset$ where $b$ belongs to and that its state is \emph{ALLOC}. If these conditions are not met, the procedure fails and returns the original \emph{bset}. If they are, the procedure picks up the tree \emph{btree} in \emph{bset} containing \emph{b}. Note that since leaves can only belong to one \emph{BlockTree}, $btree$ is unique. After this, \emph{btree} is modified into \emph{btree'} where the type of \emph{b} is set to \emph{FREE} using the functions \emph{set\_type} and \emph{replace}. After that, the new tree is coalesced using the function \textbf{merge}, and \emph{bset} is updated by replacing \emph{btree} with the new memory pool. The definition of deallocation operation is as follows.

\begin{definition} [Deallocation Operation]
	\begin{align*}
	&free\ bset\ b \triangleq \\
	&if\ \exists btree \in bset.\ b \in set\ btree\ then \\
	&\ \ \ \ if\ fst\ b = FREE\ then \\
	&\ \ \ \ \ \ \ \ return\ (bset,\ False) \\
	&\ \ \ \ else \\
	&\ \ \ \ \ \ \ \ btree = THE\ t.\ t \in bset \wedge b \in set\ t \\
	&\ \ \ \ \ \ \ \ btree' = replace\ btree\ b\ (set\_type\ b\ FREE) \\
	&\ \ \ \ \ \ \ \ btree'' = merge\ btree' \\
	&\ \ \ \ \ \ \ \ return\ (bset - \lbrace btree \rbrace \cup \lbrace btree'' \rbrace,\ True) \\
	&else\ return\ (bset,\ False)
	\end{align*}
\end{definition}

At this point, we have finished the specification of the allocation and disposal operations for a buddy memory allocator. 
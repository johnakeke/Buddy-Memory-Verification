\section{Specification of Buddy Allocation Model}
The specification of the buddy memory allocation consists of a model for the necessary data structures to represent the memory layouts, as well as the allocation and disposal operations. This specification follows the algorithms for the buddy memory management in Zephyr OS, which applies a quartering split over blocks.

\subsection{State Representation}
\label{statedes}
The specification begins with the structure of a quad-tree.
{\footnotesize
\begin{align*}
&(set:\ 'a)\ tree\ =\ Leaf\ (L:\ 'a)\ | \\
&Node\ (LL:\ 'a\ tree)\ (LR:\ 'a\ tree)\ (RL:\ 'a\ tree)\ (RR:\ 'a\ tree)
\end{align*}
}
We use inductive definition to construct a quad-tree. It has two forms: \emph{Leaf} tree and \emph{Node} tree. A \emph{Node} tree is built by itself or a \emph{Leaf} tree. The notation \emph{Leaf} means the end of this construct process. Notations \emph{LL}, \emph{LR}, \emph{RL} and \emph{RR} return corresponding subtrees of the \emph{Node} tree. Notation \textbf{set} means a function that gathers polymorphic notation \emph{'a} as a collection from all Leaf nodes.
{\footnotesize
\begin{align*}
block\_state\_type\ &=\ FREE\ |\ ALLOC \\
ID\ &=\ nat \\
Block\ &=\ (block\_state\_type\ \times\ ID)\ tree
\end{align*}
}
In this specification, we use tuple type (\emph{block\_state\_type} $\times$ \emph{ID}) to instantiate the polymorphic notation \emph{'a} in the quad-tree structure. Type \emph{block\_state\_type} stands for the usage state of a block. It consists of two subtypes indicated as \emph{ALLOC} and \emph{FREE} constructed by \emph{datatype} function. Another type \emph{ID} in basic type \emph{nat} represents address identifier of a memory block. Finally, type \emph{Block} represents an instantiated quad-tree.

In addition, we create some auxiliary functions to manipulate the \textsl{Block} tree. Function \textbf{get\_level} takes \emph{btree} and \emph{b} in \emph{Block} as inputs, then returns \emph{level} in \emph{nat} which represents the layer number that \emph{b} locates in \emph{btree} from the root note whose layer number is 0. Function \textbf{allocsets} takes a Block \emph{btree} and returns a Block set \emph{aset} of all Leaf nodes from \emph{btree}, whose \emph{block\_state\_type} are \emph{ALLOC}. Function \textbf{freesets} has a similar definition but returns \emph{FREE} ones. Function \textbf{freesets\_level} takes a Block \emph{btree} and a natural \emph{level}, then returns a Block set \emph{fset} of all Leaf nodes whose \emph{block\_state\_type} is \emph{FREE} and locate at \emph{level} in \emph{btree}. We use a notation \emph{idset} to represent the collection of all used \emph{IDs}. To create a new Leaf node, we have to pick up a new \emph{ID} to mark it by the strategy of \emph{SOME p. p} $\notin$ \emph{idset}.

Before introducing allocation model, we create a function \textbf{output\_level} that maps requested size to the allocation level in a quad-tree. The input parameters are a natural list \emph{blo\_list} and a natural \emph{rsize}. Static linked list \emph{blo\_list} is used to store all possible sizes of blocks in a quad-tree, and its indexes represent the levels of blocks located in this quad-tree. For example, the size of root node is 1024\emph{Mbytes} and the first level of quad-tree is 256\emph{Mbytes}, then \emph{blo\_list}!0 is equal to 1024 and \emph{blo\_list}!1 is 256. The \emph{blo\_list} is a strictly decreasing list to simulate the fact that the smaller the level is, the larger size the memory block owns. This function returns a natural index \emph{l} in \emph{blo\_list} with these constrains: the size it represents has to be greater than or equal to the size of requested block, and there is no smaller size that meets this condition. After that, the block size is picked up from \emph{blo\_list}, and then mapped to the correct level of the quad-tree by the index \emph{l} in \emph{blo\_list}. We use \emph{rlv} to represent the output. The definition of this mapping is as follows.

\begin{definition} [Mapping Requested Size to Allocation Level]
\label{mostsuitable}
\end{definition}
\vspace{-27pt}
{\footnotesize
\begin{align*}
&output\_level\ blo\_list\ rsize \triangleq THE\ l.\ l < \vert blo\_list \vert \\
&\wedge rsize \le blo\_list\ !\ l \\
&\wedge ((\vert blo\_list \vert > 1 \wedge l < \vert blo\_list \vert - 1) \longrightarrow rsize > blo\_list\ !\ (l+1))
\end{align*}
}
\vspace{-17pt}

\subsection{Allocation Model}
Now we specify allocation operation as function \textbf{alloc}. Firstly, we introduce two assistant functions. Function \textbf{exists\_freelevel} takes a Block set \emph{bset} (the collection of all quad-trees in memory system) and a natural \emph{rlv} as inputs. Then it returns a \emph{bool} result \emph{re}, representing whether there is a Block in \emph{bset}, that has such \emph{FREE} Leaf nodes whose levels are less than or equal to \emph{rlv}. Function \textbf{freesets\_maxlevel} has the same inputs, but it returns a natural \emph{lmax} representing the maximum level among all levels with \emph{FREE} Leaf nodes but less than or equal to \emph{rlv}. The definitions are as follows.

\begin{definition} [Existence of Free Leaf Nodes]
\end{definition}
\vspace{-7pt}
{\footnotesize
\begin{align*}
exists\_freelevel\ bset\ rlv &\triangleq \exists l.\ l \leq rlv \\
&\wedge \exists b \in bset.\ freesets\_level\ b\ l \ne \emptyset
\end{align*}
}
\vspace{-12pt}

\begin{definition} [Maximum Level of Free Leaf Nodes]
\end{definition}
\vspace{-7pt}	
{\footnotesize
\begin{align*}
&freesets\_maxlevel\ bset\ rlv \triangleq THE\ lmax.\ lmax \leq rlv \\
&\wedge \exists b \in bset.\ freesets\_level\ b\ lmax \neq \emptyset \\
&\wedge (\forall l \leq rlv.\ \exists b \in bset.\ freesets\_level\ b\ l \ne \emptyset \longrightarrow l \leq lmax)
\end{align*}
}
\vspace{-12pt}

During the allocation process, if Leaf nodes in requested level are not available, but bigger size Leaf nodes exist, then it is necessary to split a bigger size Leaf node into small Leaf nodes. This process stops until a Leaf node that satisfies the request appears. Function \textbf{split} divides a Leaf node \emph{b} into a Node tree \emph{btree} by recursion for a natural \emph{lv} times. It invokes a function \textbf{divide} that takes a Leaf node \emph{b} and returns a new non-terminal Node tree \emph{n} with four terminal Leaf nodes. The leftmost Leaf of \emph{n} is marked as \emph{ALLOC}, while the rests are marked as \emph{FREE}. The division operation always conducts on the leftmost subtree. A simple example describing this process is showed in Fig. \ref{fig1}. The recursion process stops until \emph{FREE} Leaf node in request level appears and then be allocated. We define the \emph{split} operation as follows.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.5\textwidth]{fig1.pdf}
	\caption{The progress of dividing a free leaf}
	\label{fig1}
\end{figure}

\begin{definition} [Split a Leaf Node]
\end{definition}
\vspace{-7pt}
{\footnotesize
\begin{align*}
split\ b\ lv \triangleq\ &if\ lv = 0\ then\ b \\
else\ Node\ &(split\ (LL\ divide\ b)\ (lv - 1))\ (LR\ divide\ b)\\ 
&(RL\ divide\ b)\ (RR\ divide\ b)
\end{align*}
}	
\vspace{-12pt}

In addition, we give functions \textbf{set\_type}, \textbf{replace} and \textbf{replace\_leaf} as follows: Function \emph{set\_type} takes a Leaf node \emph{b} and a target block\_state\_type \emph{s} as inputs, it changes the type of \emph{b} with \emph{s} as a new Leaf node \emph{b'}, finally it returns the new Leaf node \emph{b'}. Function \emph{replace} takes a Block \emph{btree}, two Leaf nodes \emph{b} and \emph{b'} as inputs, then it replaces the Leaf node \emph{b} with \emph{b'} in \emph{btree}, finally it returns the updated Block \emph{btree'}. Function \emph{replace\_leaf} takes a Block \emph{btree}, a Leaf node \emph{b} and a Node \emph{btr} as inputs, then it replaces the Leaf node \emph{b} with \emph{btr} in \emph{btree}, lastly it returns the updated Block \emph{btree'}.

Now we give the process of the allocation operation. It firstly checks whether there is a Block in \emph{bset} that has such \emph{FREE} Leaf nodes whose levels are less than or equal to \emph{rlv} by function \emph{exists\_freelevel}. If it returns \emph{False} then the allocation process stops and returns original \emph{bset} and \emph{False}. Otherwise, function \emph{freesets\_maxlevel} returns the maximum level \emph{lmax} among all levels with \emph{FREE} Leaf nodes but less than or equal to \emph{rlv}. Two branches are as follows.

If \emph{lmax} is equal to requested level \emph{rlv}, then the allocation operation randomly picks up such a Block tree as \emph{btree}, that has such \emph{FREE} Leaf nodes whose levels are equal to \emph{rlv}. After this, it randomly picks up a \emph{FREE} Leaf node \emph{l} in level \emph{rlv} from \emph{btree}. Then function \emph{set\_type} is invoked to set the type of \emph{l} as \emph{ALLOC}, and to return a new Leaf node \emph{l'}. Next, the opearation invokes function \emph{replace} to update \emph{btree} with \emph{l'}, and to return \emph{btree'}. After that, the allocation operation updates Block set \emph{bset} by replacing previous \emph{btree} with \emph{btree'}. Finally, the operation returns updated Block set and \emph{True}.

If \emph{lamx} is not equal to requested level \emph{rlv}, then the allocation operation randomly picks up such a Block tree as \emph{btree}, who has \emph{FREE} Leaf nodes in level \emph{lmax}. After that, it randomly picks up a \emph{FREE} Leaf node \emph{l} in level \emph{lmax} from \emph{btree}. Then function \emph{split} is invoked to split \emph{l} into Node tree \emph{btr}. Next, the operation invokes function \emph{replace\_leaf} to update \emph{btree} with \emph{btr}, and to return \emph{btree'}. After this, the allocation operation updates Block set \emph{bset} by replacing previous \emph{btree} with \emph{btree'}. Finally, the operation returns updated Block set and \emph{True}. The definition of allocation operation is as follows.

\begin{definition} [Allocation Operation]
\end{definition}
\vspace{-7pt}
{\footnotesize
\begin{align*}
alloc\ &bset\ rlv \triangleq \\
&if\ exists\_freelevel\ bset\ rlv\ then \\
&\ \ \ \ lmax = freesets\_maxlevel\ bset\ rlv \\
&\ \ \ \ if\ lmax = rlv\ then \\
&\ \ \ \ \ \ \ \ btree = SOME\ b.\ b \in bset \wedge freesets\_level\ b\ rlv \ne \emptyset \\
&\ \ \ \ \ \ \ \ l = SOME\ l.\ l \in freesets\_level\ btree\ rlv \\
&\ \ \ \ \ \ \ \ btree' = replace\ btree\ l\ (set\_type\ l\ ALLOC) \\
&\ \ \ \ \ \ \ \ return\ (bset - \lbrace btree \rbrace \cup \lbrace btree' \rbrace, True) \\
&\ \ \ \ else \\
&\ \ \ \ \ \ \ \ btree = SOME\ b.\ b \in bset \wedge freesets\_level\ b\ lmax \ne \emptyset \\
&\ \ \ \ \ \ \ \ l = SOME\ l.\ l \in freesets\_level\ btree\ lmax \\
&\ \ \ \ \ \ \ \ btr' = split\ l\ (rlv - lmax) \\
&\ \ \ \ \ \ \ \ btree' = replace\_leaf\ btree\ l\ btr' \\
&\ \ \ \ \ \ \ \ return\ (bset - \lbrace btree \rbrace \cup \lbrace btree' \rbrace, True) \\
&else\ return\ (bset, False)
\end{align*}
}
\vspace{-17pt}

\subsection{Deallocation Model}
During the deallocation process, if such a situation appears that four Leaf nodes belonging to a same parent Node are all \emph{FREE}, then function \textbf{merge} is invoked to merge these Leaf nodes to one Leaf node. It invokes function \textbf{combine} that takes a Node tree \emph{n} and returns a new terminal Leaf node \emph{l} \emph{iff} Node tree \emph{n} has four terminal \emph{FREE} Leaf nodes. Function \emph{merge} takes a Node tree \emph{n} and recursively invokes \emph{combine} on each sub-node of \emph{n} and \emph{n} itself. A simple example that describes the merging process is showed in Fig. \ref{fig2}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.5\textwidth]{fig2.pdf}
	\caption{The progress of merging all free memory blocks}
	\label{fig2}
\end{figure}

With above discussion, we give the process of deallocation operation. It firstly checks whether there is a Block tree in \emph{bset} whom the Leaf node \emph{b} to be deposed belongs to. If there is no such tree, the procedure returns the original \emph{bset} and \emph{False}. Otherwise, if the type of \emph{b} is \emph{FREE}, it also returns the original \emph{bset} and \emph{False}. When all conditions are met, it picks up the Block tree in \emph{bset} as \emph{btree} whom \emph{b} belongs to. After this, the operation invokes function \emph{set\_type} to set the type of \emph{b} as \emph{FREE}, and to return a new Leaf node \emph{b'}. Next, it invokes function \emph{replace} to update \emph{btree} with \emph{b'}, and to return \emph{btree'}. After that, the deallocation operation invokes \emph{merge} to perform a necessary merging operation on \emph{btree'}, and to return \emph{btree''}. Next, the operation updates Block set \emph{bset} by replacing previous \emph{btree} with \emph{btree''}. Finally, the deallocation operation returns updated Block set and \emph{True}. The definition of deallocation operation is as follows.

\begin{definition} [Deallocation Operation]
\end{definition}
\vspace{-7pt}
{\footnotesize
\begin{align*}
free\ &bset\ b \triangleq \\
&if\ \exists btree \in bset.\ b \in set\ btree\ then \\
&\ \ \ \ if\ fst\ b = FREE\ then \\
&\ \ \ \ \ \ \ \ return\ (bset, False) \\
&\ \ \ \ else \\
&\ \ \ \ \ \ \ \ btree = THE\ t.\ t \in bset \wedge b \in set\ t \\
&\ \ \ \ \ \ \ \ btree' = replace\ btree\ b\ (set\_type\ b\ FREE) \\
&\ \ \ \ \ \ \ \ btree'' = merge\ btree' \\
&\ \ \ \ \ \ \ \ return\ (bset - \lbrace btree \rbrace \cup \lbrace btree'' \rbrace, True) \\
&else\ return\ (bset, False)
\end{align*}
}
\vspace{-12pt}

At this point, we have finished the specification for a buddy memory allocation algorithm. Next, we are going to verify its functional correctness and security property.
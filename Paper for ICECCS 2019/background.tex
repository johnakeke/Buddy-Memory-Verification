\section{Background}
In this section we give the necessary background for the buddy allocation algorithms we provide the specification for, and the Isabelle/HOL theorem prover that we use for its specification and verification.

\subsection{Buddy Allocation Algorithm}
The buddy memory system was originally described by~\cite{reg_knowlton}. Today it is widely used in many operation systems, in particular most versions of UNIX. For example, BSD~\cite{reg_mckusick} uses the buddy memory system for blocks smaller than a page, i.e., 4 kilobytes. The classic description of the buddy system is released by~\cite{reg_knuth}.

According to the algorithms, free blocks on each size are maintained in a multilevel list, as a result it is easy to find a block of the requested size if one is available. If there is no block of the requested size, allocation operation will search for the first nonempty free list for blocks, starting from the level where the requested size is allocated. Then a large block which is picked from the nonempty free list is split, it is divided into two smaller blocks and each smaller block becomes an unique buddy to the other. If the size of smaller block is still too large, one of the two smaller blocks is split again. The split process stops until the requested size appears. Then one of the available blocks is marked as occupied and returned to the requesting application. The others are added to the appropriate free lists.

When a block is deallocated, the algorithms checks whether the block can be merged. A split block can only be merged with its unique buddy block, which then reforms the larger block they were split from. Among this process, the algorithms apply a flag bit strategy to quickly check if blocks belonging to the same parent are free, in order to decide whether to merge these blocks into one block. With this way, buddy memory system has small external fragmentation.

To implement buddy allocation algorithms, it applies two important data structures multilevel free linked-list and multilevel free bitmap. The block to be allocated or deallocated is directly picked from the head of linked-list or added into the tail. Bitmap uses 0 and 1 to implement the flag bit strategy. Fig. \ref{fig3} describes a moment in memory system using these two date structures.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.5\textwidth]{fig3.pdf}
	\caption{Structures in Buddy Allocation Algorithms}
	\label{fig3}
\end{figure}

\subsection{Isabelle/HOL}
We use the interactive theorem prover Isabelle/HOL~\cite{reg_Isabelle/HOL} to conduct the specification and verification of the memory management. Isabelle/HOL is a higher order logic theorem prover, using a typed lambda calculus-like functional language for specifications. 

Isabelle/HOL includes a specification for simple common types such as naturals, integers, and booleans. It also specify some composed data types like tuples, records, lists, and sets that are parametrized on other types. Isabelle provides the interface \emph{datatype} for the creation of user defined types based on type constructors. 

Isabelle provides functions on predefined types to access their members or to provide additional operations over them. In the following we describe those functions that we use along this work. Tuples are denoted as (\emph{$t_1$} $\times$ \emph{$t_2$}), projection function \emph{fst} and \emph{snd} respectively returns elements $t_1$ and $t_2$. Lists are defined as a datatype with an empty construct denoted with \emph{NIL} or $[]$, and a concatenation construct denoted with $\#$, where $x\#xs$ adds $x$ to the front of $xs$. The $i$th component of a list $as$ is written as $as!i$. Isabelle/HOL provides functions for definite and indefinite descriptions. Definitive descriptions are represented by $THE\ x.\ P\ x$ and return the element uniquely described by the predicate $P$, else it returns and undefined value. Indefinite descriptions are represented by $SOME\ x.\, P\ x$ selecting a random element from the predicate $P$ that must describe at least one element, else it returns an arbitrary value.

Isabelle/HOL allows user to create non-recursive specifications using the command \emph{definition}, and to create recursive specifications using commands \emph{primrec} and \emph{recursive}.

%The notation {\isasymlbrakk} $A_1$;\dots;$A_n${\isasymrbrakk} $\Longrightarrow$ A represents an implication with assumptions $A_1$;\dots;$A_n$ and conclusion A. Isabelle mainly employs backward deduction, which means to prove the main goal, we must firstly prove subgoals which are decomposed from the main goal. It uses the rules of the reasoning like introduction, elimination, destruction rules, etc., as well as automatic provers such as \emph{SMT}.

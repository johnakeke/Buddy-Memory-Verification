\section{Verification for Memory Model Specification}
To guarantee functional correctness of the formal model we proof a number of properties related to the transformations that the operations carry out over the memory structure. We try to answer the following questions: do the operations pick out the most suitable block from all the available blocks? is the state of the data structures representing the memory correctly set after executing the operations? are free blocks properly merged after a disposal operation? Answering these questions contributes to the construction of a reliable memory system.

Once the specification is finished, the preconditions $\&$ postconditions for functions as well as the invariants are to be raised up to ensure the functional correctness of the specification. We give preconditions and postconditions in the first place.

The following Def. \ref{pp1} gives such an implication: if there is not a quad-tree in \emph{blo\_set} that has free memory blocks whose level is less than or equal to \emph{rlv}, nothing is to be changed because of the allocation failure.

\begin{definition} [Allocation Failure] \\
	$\neg$ exists\_freelevel blo\_set rlv $\longrightarrow$ fst (alloc blo\_set rlv) = blo\_set
	\label{pp1}
\end{definition}

Then Def. \ref{pp2} and Def. \ref{pp3} respectively describe the block to be allocated no longer belongs to the free sets and is part of allocated sets during the direct allocation process.

\begin{definition} [Freesets for Direct Allocation] \\
	exists\_freelevel blo\_set rlv $\wedge$ freesets\_maxlevel blo\_set rlv = rlv $\longrightarrow$ \\
	\phantom{x} \hspace{10pt} $\exists$l. l $\in$ freesets blo\_set $\wedge$ l $\notin$ freesets fst (alloc blo\_set rlv) $\wedge$ \\
	\phantom{x} \hspace{10pt} freesets blo\_set = freesets fst (alloc blo\_set rlv) $\cup$ $\lbrace$l$\rbrace$
	\label{pp2}
\end{definition}

\begin{definition} [Allocsets for Direct Allocation] \\
	exists\_freelevel blo\_set rlv $\wedge$ freesets\_maxlevel blo\_set rlv = rlv $\longrightarrow$ \\
	\phantom{x} \hspace{10pt} $\exists$l. l $\notin$ allocsets blo\_set $\wedge$ l $\in$ allocsets fst (alloc blo\_set rlv) $\wedge$ \\
	\phantom{x} \hspace{10pt} allocsets fst (alloc blo\_set rlv) = allocsets blo\_set $\cup$ $\lbrace$l$\rbrace$
	\label{pp3}
\end{definition}

Next Def. \ref{pp4} says that a new block created from splitting a bigger block is allocated and belongs to the allocated sets during indirect allocation, which means \emph{split} operation is needed.

\begin{definition} [Allocsets for Indirect Allocation] \\
	exists\_freelevel blo\_set rlv $\wedge$ freesets\_maxlevel blo\_set rlv $\neq$ rlv $\longrightarrow$ \\
	\phantom{x} \hspace{10pt} $\exists$l. l $\notin$ allocsets blo\_set $\wedge$ l $\in$ allocsets fst (alloc blo\_set rlv) $\wedge$ \\
	\phantom{x} \hspace{10pt} allocsets fst (alloc blo\_set rlv) = allocsets blo\_set $\cup$ $\lbrace$l$\rbrace$
	\label{pp4}
\end{definition}

The next two Def. \ref{pp5} and Def. \ref{pp6} guarantee nothing to be changed during the deallocation process because of the non-existence of such a quad-tree that the block to be released belongs to or the type of the block to be freed is \emph{FREE}.

\begin{definition} [Deallocation failure 1] \\
	$\nexists$btree $\in$ blo\_set. b $\in$ tree.set btree $\longrightarrow$ fst (free blo\_set b) = blo\_set
	\label{pp5}
\end{definition}

\begin{definition} [Deallocation failure 2] \\
	$\exists$btree $\in$ blo\_set. b $\in$ tree.set btree $\wedge$ type b = FREE $\longrightarrow$ \\
	\phantom{x} \hspace{10pt} fst (free blo\_set b) = blo\_set
	\label{pp6}
\end{definition}

The last Def. \ref{pp7} tells that the block to be deallocated does not belong to allocated sets any more.

\begin{definition} [Allocsets for Deallocation Success] \\
	$\exists$btree $\in$ blo\_set. b $\in$ tree.set btree $\wedge$ type b $\neq$ FREE $\longrightarrow$ \\
	\phantom{x} \hspace{10pt} allocsets blo\_set = allocsets fst (free blo\_set b) $\cup$ $\lbrace$b$\rbrace$
	\label{pp7}
\end{definition}

After giving these definitions for preconditions and postconditions, we try to prove that our buddy allocation specification satisfies them so that it meets the functional expectations. The first theorem we prove as follows.

\begin{theorem}
The buddy allocation specification satisfies all the preconditions and postconditions above.
\end{theorem}

\begin{proof}
	All parts can be formally proved by induction on the type of a quad-tree, including leaf and node types. And the proofs on node type can be conducted by another induction which is on the height of the derivation.
\end{proof}

Through preconditions and postconditions, the specification can be proved that it partly follows the expectations of the algorithms. Next to guarantee that the algorithms pock out the most suitable block, two properties have to be proved: 1. the correctness of the mapping from the request memory block size to the level of the quad-tree. 2. the correctness of the quad-tree hierarchical structure. Here are these two properties.



 Function \textbf{L} is used to get the length of a list. As mentioned above, the smaller the level, the larger size the memory block.  Some lemmas ensure the correctness of this definition.

\begin{lemma}
	L blo\_list $>$ 0 $\wedge$ rsize $\leq$ blo\_list ! (L blo\_list - 1) $\longrightarrow$ output\_level blo\_list rsize = L blo\_list - 1
\end{lemma}

\begin{lemma}
	L blo\_list $>$ 1 $\wedge$ l $<$ L blo\_list - 1 $\wedge$ rsize $\leq$ blo\_list ! l $\wedge$ rsize $>$ blo\_list ! (l + 1) $\longrightarrow$ output\_level blo\_list rsize = l
\end{lemma}

\begin{proof}
	By unfolding the definition of output\_level, two aspects including existence and uniqueness have to be proved for the notion THE. The first part existence can be proved by the given assumptions. The remaining part uniqueness can be proved by the strictly decreasing blo\_list.
\end{proof}

Next, we introduce a lemma alone to prove the correctness of a quad-tree structure from the aspect of its levels. The \textbf{root} checks whether the tree is a root tree and \textbf{child} gives us all immediate child nodes.

\begin{lemma}
	(root btree $\longrightarrow$ get\_level btree = 0) $\wedge$ (get\_level btree = l $\wedge$ l $\geq$ 0 $\wedge$ chtree $\in$ child btree $\longrightarrow$ get\_level chtree = l + 1)
\end{lemma}

\begin{proof}
	This lemma can be formally proved by induction on the height of the derivation.
\end{proof}

Until now, we have already proved the correctness of the mapping operation and the hierarchical structure of a quad-tree. Then we can deduce the following theorem to guarantee the property of picking out the most suitable memory block.

\begin{theorem}
	The buddy allocation specification picks out the most suitable memory block and operates on the correct level in a quad-tree.
\end{theorem}

The algorithms are designed to avoid the fragmentation by merging operation which is invoked in the process of deallocation. Whether this operation is executed correctly can not be proved from the surface. In order to prove this property, we still start from the structural correctness of the quad-tree. Considering the fact that there is not such a node whose four child nodes are all leaves and their types are \emph{FREE} after merging operation, a definition to check whether a tree is like this can be constructed as follows. The \textbf{leaf} is to check whether the tree is a leaf.

\begin{definition} [Four Free Leaves Belong to The Same Node] \\
	is\_FFL btree $\equiv$ $\forall$chtree $\in$ child btree. leaf chtree $\wedge$ type chtree = FREE
\end{definition}

Fig. \ref{fig2} can explain this definition well. Just like the subtree in the lower left corner of the first picture, four child nodes are all leaves and their types are \emph{FREE}. Therefore, merging operation is necessary during the progress of deallocation to handle this situation. The following are the lemmas that ensure the non-existence of such \emph{FFL} trees after allocation and deallocation operations if non-existence of such trees in preconditions.

\begin{lemma}
	$\forall$b $\in$ blo\_set. $\neg$ is\_FFL b $\longrightarrow$ $\forall$b $\in$ fst (alloc blo\_set rlv). $\neg$ is\_FFL b
\end{lemma}

\begin{lemma}
	$\forall$b $\in$ blo\_set. $\neg$ is\_FFL b $\longrightarrow$ $\forall$b $\in$ fst (free blo\_set b). $\neg$ is\_FFL b
\end{lemma}

\begin{proof}
	Apply cases to these two lemmas after folding the definitions of allocation and deallocation operations. For each cases, they can be proved by induction on the height of the derivation.
\end{proof}

After memory initialization, assuming that all blocks to be allocated are the original ones which are not split, this beginning of the moment satisfies non-existence of \emph{FFL} trees among all quad-trees because all available blocks are seen as root trees. This assertion satisfies the assumptions in the implication expressions above. Therefore, through any execution orders of allocation and deallocation operations, the whole memory system satisfies non-existence of the \emph{FFL} trees. We have this theorem as follows.

\begin{theorem}
	The buddy allocation specification guarantees non-existence of FFL trees among all quad-trees.
\end{theorem}

In the end, we prove two significant properties: memory isolation and non-leakage. The first one is to prove non-existence of the overlap in the address spaces. Isolation in address spaces makes sure domains' memory blocks are not maliciously overwritten. Memory leakage means that available memory blocks (including occupied and free blocks) are getting less and less. Then non-leakage is to protect the integrity of address spaces.

Now we begin with the memory isolation. For the specification level, we provisionally use \emph{ID} to represent a contiguous addresses for a memory block. When we introduce real addresses into the specification, two things have to be proved: 1. the correctness of mapping function between a \emph{ID} and a true range of address; 2. the one-to-one uniqueness between them. In this paper, we are not going to introduce real addresses and we assume the above properties are all correct. Therefore, in this specification, isolation in address spaces means that all \emph{IDs} that leaves bring are different. What we prove to guarantee the difference of \emph{IDs} is the strategy of creating a new leaf that has been already introduced in the subsection 3.1.

The following definition tells that there are no two leaves with the same \emph{ID}. The \textbf{ID} gives the id the leaf brings. Firstly, we pick up any quad-tree \emph{b} from the tree collection \emph{blo\_set}. Then we select any leaf \emph{l} from this quad-tree. Our criterion is that there is not such a leaf \emph{l'} picked up from any quad-tree that is different from \emph{l} but has the same \emph{ID} with \emph{l}.

\begin{definition} [Different IDs] \\
	is\_different blo\_set $\equiv$ $\forall$b $\in$ blo\_set. $\forall$l $\in$ tree.set b. ($\nexists$l'. l' $\in$ tree.set (SOME b. b $\in$ blo\_set) $\wedge$ l' $\ne$ l $\wedge$ ID l' = ID l)
\end{definition}

Below are two lemmas that ensure this property holds during the procedures of allocation and deallocation if it holds in preconditions.

\begin{lemma}
	is\_different blo\_set $\longrightarrow$ is\_different fst (alloc blo\_set rlv)
\end{lemma}

\begin{lemma}
	is\_different blo\_set $\longrightarrow$ is\_different fst (free blo\_set b)
\end{lemma}

\begin{proof}
	Firstly apply cases to these two lemmas after folding the definitions of allocation and deallocation operations. Then for each cases, they can be proved by induction on the height of the derivation.
\end{proof}

With above lemmas of different \emph{IDs}, we can ensure all \emph{IDs} are different by using our strategy to create a new leaf. The following is the theorem that says this.

\begin{theorem}
	The buddy allocation specification ensures all IDs of leaves are different.
\end{theorem}

Finally, combined with the assumptions that mapping function between a \emph{ID} and a true range of address is correct, memory isolation in addresses can be proved.

Next is for the non-leakage of blocks. Result from we use the quad-tree structure and map all the memory blocks into the leaves of these trees, thence the non-leakage means that all the leaves (including occupied and free leaves) are in use. If we can infer that the quad-tree always maintains correct structure from the aspect of a relation between the number of nodes and leaves, then we can prove that all the leaves are in use and none leaf is forgotten. The first step is to prove a relation between the number of nodes and leaves in a quad-tree. Functions \textbf{Leaf} and \textbf{Node} give all the leaves and nodes in a quad-tree \emph{b}.

\begin{lemma}
	q-tree b: Num (Leaf b) = Num (Node b) $\times$ 3 + 1
\end{lemma}

\begin{proof}
	This lemma can be formally proved by induction on the type of quad-tree b, including leaf and node types. If quad-tree b is a leaf which means it is also a root, then the number of leaves is 1 and the number of nodes is 0. The lemma can be proved. If quad-tree b is a node with the inductive assumptions that this relation in the number of leaves and nodes holds for all the subtrees in b, this lemma still can be proved because of the quad-tree structure of b itself.
\end{proof}

Having established this relation, we use the following two lemmas to guarantee all the quad-trees during the procedures maintain this relation in the number of leaves and nodes.

\begin{lemma}
	$\forall$b $\in$ blo\_set. q-tree b $\longrightarrow$ $\forall$b $\in$ fst (alloc blo\_set rlv). q-tree b
\end{lemma}

\begin{lemma}
	$\forall$b $\in$ blo\_set. q-tree b $\longrightarrow$ $\forall$b $\in$ fst (free blo\_set b). q-tree b
\end{lemma}

\begin{proof}
	Fold the definitions of allocation and deallocation operations firstly. Then apply cases to these two lemmas. For each cases, they can be proved by induction on the height of the derivation.
\end{proof}

In the end, we can prove that all quad-trees holds this relation in the number of leaves and nodes. That is to say all leaves (including occupied and free leaves) are in use. Then considering the fact that all blocks are mapped into the leaves of these trees, we can ensure non-leakage of memory in our specification.

\begin{theorem}
	The buddy allocation specification guarantees any tree is a q-tree.
\end{theorem}

To sum up, in this section we introduce the quad-tree structure to simulate memory because of the buddy allocation algorithms. Then we give a specification for the algorithms including \textbf{alloc} and \textbf{free} operations. After that, we give proofs for functional correctness including preconditions and postconditions, the most suitable memory block, non-existence of the \emph{FFL} trees, memory isolation and non-leakage. Through these efforts, we give a functionally correct buddy memory model.
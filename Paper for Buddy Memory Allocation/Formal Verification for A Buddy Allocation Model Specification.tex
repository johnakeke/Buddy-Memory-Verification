\documentclass[runningheads]{llncs}
\usepackage{graphicx}
\usepackage{amssymb,amsmath}

\begin{document}

\title{Formal Verification for A Buddy Allocation Model Specification
	\thanks{Supported by organization x.}}


\author{Ke Jiang\inst{1} \and
		Yongwang Zhao\inst{2,3} \and
		David San\'{a}n\inst{1} \and
		Yang Liu\inst{1}}

\authorrunning{Ke Jiang et al.}


\institute{School of Computer Science and Engineering, \\
			Nanyang Technological University, Singapore \\ 
	\email{johnjiang,sanan,yangliu@ntu.edu.sg} \and
			School of Computer Science and Engineering, \\
			Beihang University, Beijing, China \and
			Beijing Advanced Innovation Center for Big Data and Brain Computing, \\
			Beihang University, Beijing, China \\
	\email{zhaoyw@buaa.edu.cn}}

\maketitle


\begin{abstract}
Buddy allocation algorithms are widely adopted by memory management systems to manage the address space accessed by applications. However, errors in any stage of the development process of the memory management component, from the specification to the implementation, may lead to critical issues in other components using it. We apply formal methods to ensure the absence of any misbehavior. Rigorous mathematical proofs provide strong assurance to the development process. In this paper, we firstly present a specification for the buddy allocation algorithm. And thence we validate enough properties to guarantee functional correctness of this algorithm. Finally, we construct execution traces to verify the integrity for security. Through these efforts, we propose a buddy allocation model that provides both functional correctness and security. Also, we use interactive theorem prover Isabelle/HOL to carry out the verification work.

\keywords{Memory Specification \and
		Formal Verification \and
		Functional Correctness \and
		Security.}
\end{abstract}


\section{Introduction}
In the past several decades, buddy allocation algorithms have been applied in the memory management systems. Errors in any stage of the development process of the memory management component may lead to critical issues in other components who invoke it. To improve confidence on the reliability of the development process, verification of functional correctness and security properties is applied into each stage, from the specification level to the implementation level, even the machine code level. Formal methods have been successfully applied in the verification of many critical systems due to these methods provide strong assurance by rigorous mathematical proofs. Therefore, we apply formal methods to ensure the absence of any misbehavior during the development process of the buddy allocation model.

here is related work.

In this paper, we propose a buddy allocation model, which supports both functional correctness and security. To achieve this goal, we develop a specification for buddy allocation algorithms by functional programming in Isabelle/HOL proof assistant. Our specification must consists of algorithm details as specific as possible for the sake of capturing any feature in the algorithms. Then we design a series of properties for functional correctness of the algorithm. After that, we apply theorem-proving method to prove these properties. To verify integrity for security, we construct execution traces based on event, and then prove that the operation of one domain on memory does not affect any other domains. So far, we have completed the construction and verification of the buddy allocation algorithm.

The following section briefly introduces the Isabelle/HOL verification environment. The next section is about the formalization of buddy allocation model including representation of our specification and proofs to properties for functional correctness. The verification of integrity for security is arranged in the following section. The last section is about the conclusions and future work.


\section{Isabelle/HOL Verification Environment}
Our specification and verification work is based on the interactive theorem prover Isabella/HOL. HOL represents the Higher-Order Logical and Isabelle is its generic interactive theorem prover. In Isabelle/HOL, it is usual to employ functional programming method to define a function and to adopt theorem proving technique to reason a lemma or a theorem. For a gentle introduction to Isabelle/HOL see~\cite{reg_Isabelle/HOL}. 

Apart from commonly used types like \textsl{bool} and \textsl{nat}, Isabelle offers notion \textsl{datatype} to create a distinguished element to some existing types. Projection functions \textsl{fst} and \textsl{snd} comes with the tuple (\textsl{$t_1$} $\times$ \textsl{$t_2$}). Notions \textsl{list} and \textsl{set} are used as constructors to create a collection of same type. Operation 'cons' denoted by '$\#$' on a list means that adding an element to the head of list. The \textsl{i}th component of a list \textsl{xs} is written as \textsl{xs}!\textsl{i}. \textsl{SOME x} and \textsl{THE x} in the \textsl{set A} represent choosing an element arbitrarily, existing and unique element respectively. Furthermore, $\lambda$-abstractions are also contained in terms like $\lambda$(\textsl{x, y}). \textsl{f x y}.

Non-recursive definition can be made with the \textbf{definition} command and the \textbf{primrec} function definition is used for primitive recursions. The notation $\lbrack$ $A_1$;\dots;$A_n$$\rbrack$ $\Longrightarrow$ A represents an implication with assumptions $A_1$;\dots;$A_n$ and conclusion A. Isabelle mainly employs backward deduction, which means to prove the main goal, we must firstly prove subgoals which are decomposed from the main goal. It uses the rules of the reasoning like introduction, elimination, destruction rules, etc., as well as automatic provers such as \textsl{SMT}.


\section{Formalization of Buddy Allocation Model}
The formalization of buddy allocation models consists of a specification for algorithms and proofs to properties for functional correctness. The challenge is that we apply quartering from Zephyr OS for buddy allocation operations, which brings complexity to proofs.

\subsection{Memory Model Specification}
The specification begins with the structure of a quad-tree.
\begin{align*}
(set:\ 'a)\ tree = &Leaf\ (L:\ 'a)\ | \\
&Node\ (LL:\ 'a\ tree)\ (LR:\ 'a\ tree)\ (RL:\ 'a\ tree)\ (RR:\ 'a\ tree) \\
&for\ map: tree\_map
\end{align*}
The quad-tree constructed by induction contains two pieces of information: the memory block state (indicated as \textsl{ALLOC} and \textsl{FREE} respectively); a address tag occupied by a memory block (indicated as \textsl{ID}). The mapping function \textbf{set} assists to collect the leaves from a tree. With the help of the block state and the function \textbf{get\_level}, allocated leaves or free leaves from different levels can be gathered by \textbf{allocsets}, \textbf{freesets} and \textbf{freesets\_level}. To create a new leaf, we have to pick up a new \textsl{ID} to this new leaf by the strategy of \textsl{SOME p. p} $\notin$ \textsl{idset}. Later, we will prove that with this strategy, all leaves have different \textsl{IDs}.

Based on the above quad-tree structure, next we specify two operations with the buddy algorithms: \textbf{alloc} and \textbf{free}. For \textsl{rsize} (the size of requested memory block) in allocation operation, there is a definition that maps it to the level of the quad-tree and gives the most suitable level \textsl{rlv}. The concept of \textsl{most suitable level} will be proved in the next subsection. For the specification, we only use level for both the memory blocks of the quad-tree and requested memory block. And the smaller the level, the larger size the memory block.

\begin{definition} {exists\_freelevel} \\
exists\_freelevel blo\_set lv $\equiv$ $\exists$l. l $\leq$ lv $\wedge$ $\exists$b $\in$ blo\_set. freesets\_level b l $\ne$ $\emptyset$
\end{definition}

\begin{definition} {freesets\_maxlevel}\\
freesets\_maxlevel blo\_set lv $\equiv$ \\
\phantom{x} \hspace{10pt} THE lmax. lmax $\leq$ lv $\wedge$ \\
\phantom{x} \hspace{60pt} $\exists$b $\in$ blo\_set. freesets\_level b lmax $\neq$ $\emptyset$ $\wedge$ \\
\phantom{x} \hspace{60pt} $\forall$l $\leq$ lv. $\exists$b $\in$ blo\_set. freesets\_level b l $\ne$ $\emptyset$ $\longrightarrow$ l $\leq$ lmax
\end{definition}

\begin{definition} {Allocation Operation} \\
alloc blo\_set rlv $\equiv$ \\
\phantom{x} \hspace{10pt} if exists\_freelevel blo\_set rlv then \\
\phantom{x} \hspace{20pt} lmax = freesets\_maxlevel blo\_set rlv \\
\phantom{x} \hspace{20pt} if lmax = rlv then \\
\phantom{x} \hspace{30pt} btree = SOME b. b $\in$ blo\_set $\wedge$ freesets\_level b rlv $\ne$ $\emptyset$ \\
\phantom{x} \hspace{30pt} l = SOME l. l $\in$ freesets\_level btree rlv \\
\phantom{x} \hspace{20pt} else \\
\phantom{x} \hspace{30pt} btree = SOME b. b $\in$ blo\_set $\wedge$ freesets\_level b lmax $\ne$ $\emptyset$ \\
\phantom{x} \hspace{30pt} l = split (SOME l. l $\in$ freesets\_level btree lmax) (rlv - lmax) \\
\phantom{x} \hspace{10pt} else False
\end{definition}

The first step of allocation is to check whether there is a quad-tree in \textsl{blo\_set} (the memory pool tree collection), that has such free memory blocks whose level is less than or equal to \textsl{rlv}. This step is done by \textbf{exists\_freelevel}, and if it returns \textsl{False} then the allocation progress stops. Otherwise, the next step conducted by \textbf{freesets\_maxlevel} is to return the maximum level among all levels with free memory blocks. If the maximum level is equal to \textsl{rlv}, then any free memory block in \textsl{rlv} is to be allocated. If not, any free memory block in the maximum level is to be conducted by \textbf{split} showed in Fig. \ref{fig1} until free memory block in \textsl{rlv} appears and then be allocated. The state of the assigned leaf is set to \textsl{ALLOC}.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{fig1.pdf}
\caption{The progress of dividing a free memory block}
\label{fig1}
\end{figure}

\begin{definition} {Deallocation Operation} \\
free blo\_set b $\equiv$ \\
\phantom{x} \hspace{10pt} if $\exists$btree $\in$ blo\_set. b $\in$ tree.set btree then \\
\phantom{x} \hspace{20pt} if State b = FREE then False \\
\phantom{x} \hspace{20pt} else btree = THE t. t $\in$ blo\_set $\wedge$ b $\in$ tree.set t \\
\phantom{x} \hspace{40pt} merge (reset btree b FREE) \\
\phantom{x} \hspace{10pt} else False
\end{definition}

The deallocation progress firstly checks whether there is a quad-tree in \textsl{blo\_set} that the occupied memory block to be released belongs to this tree. If there is no such tree, the procedure returns \textsl{False}. Next, if the state of the occupied memory block is \textsl{FREE}, the progress also returns \textsl{False}. When all conditions are met, the memory block is returned to the tree it belongs to, thereafter merging operation is executed. The merging operation is to combine all free memory blocks that belong to the same parent tree showed in Fig. \ref{fig2}.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{fig2.pdf}
\caption{The progress of merging all free memory blocks}
\label{fig2}
\end{figure}

At this point, we have done the specification for the buddy memory algorithm. Next, we are going to verify some properties to guarantee the functional correctness of this specification.


\subsection{Memory Model Properties}
Once the specification is finished, the preconditions $\&$ postconditions for functions as well as the invariants are to be raised up to ensure the functional correctness of the specification. We try to answer these questions: Does the algorithm pick out the most suitable block from all the available blocks? Does the algorithm correctly adjust the state of the relevant memory block after allocation and deallocation? How does the algorithm make sure to execute the merging operation after deallocation? How does the specification ensure the correctness of the quad-tree structure? What invariants does the specification preserve? Does the algorithm satisfy some security properties? Answering these questions contributes to the construction of a reliability system. We give preconditions and postconditions in the first place.

\begin{definition} {Allocation Failure} \\
$\neg$ exists\_freelevel blo\_set rlv $\longrightarrow$ fst (alloc blo\_set rlv) = blo\_set
\end{definition}

\begin{definition} {Freesets for Direct Allocation} \\
exists\_freelevel blo\_set rlv $\wedge$ freesets\_maxlevel blo\_set rlv = rlv $\longrightarrow$ \\
\phantom{x} \hspace{10pt} $\exists$l. l $\in$ freesets blo\_set $\wedge$ l $\notin$ freesets fst (alloc blo\_set rlv) $\wedge$ \\
\phantom{x} \hspace{10pt} freesets blo\_set = freesets fst (alloc blo\_set rlv) $\cup$ $\lbrace$l$\rbrace$
\end{definition}

\begin{definition} {Allocsets for Direct Allocation} \\
exists\_freelevel blo\_set rlv $\wedge$ freesets\_maxlevel blo\_set rlv = rlv $\longrightarrow$ \\
\phantom{x} \hspace{10pt} $\exists$l. l $\notin$ allocsets blo\_set $\wedge$ l $\in$ allocsets fst (alloc blo\_set rlv) $\wedge$ \\
\phantom{x} \hspace{10pt} allocsets fst (alloc blo\_set rlv) = allocsets blo\_set $\cup$ $\lbrace$l$\rbrace$
\end{definition}

\begin{definition} {Allocsets for Indirect Allocation} \\
exists\_freelevel blo\_set rlv $\wedge$ freesets\_maxlevel blo\_set rlv $\neq$ rlv $\longrightarrow$ \\
\phantom{x} \hspace{10pt} $\exists$l. l $\notin$ allocsets blo\_set $\wedge$ l $\in$ allocsets fst (alloc blo\_set rlv) $\wedge$ \\
\phantom{x} \hspace{10pt} allocsets fst (alloc blo\_set rlv) = allocsets blo\_set $\cup$ $\lbrace$l$\rbrace$
\end{definition}

\begin{definition} {Deallocation failure 1} \\
$\nexists$btree $\in$ blo\_set. b $\in$ tree.set btree $\longrightarrow$ fst (free blo\_set b) = blo\_set
\end{definition}

\begin{definition} {Deallocation failure 2} \\
$\exists$btree $\in$ blo\_set. b $\in$ tree.set btree $\wedge$ State b = FREE $\longrightarrow$ \\
\phantom{x} \hspace{10pt} fst (free blo\_set b) = blo\_set
\end{definition}

\begin{definition} {Allocsets for Deallocation Success} \\
$\exists$btree $\in$ blo\_set. b $\in$ tree.set btree $\wedge$ State b $\neq$ FREE $\longrightarrow$ \\
\phantom{x} \hspace{10pt} allocsets blo\_set = allocsets fst (free blo\_set b) $\cup$ $\lbrace$b$\rbrace$
\end{definition}

\begin{theorem}
The buddy allocation specification satisfies all the preconditions and postconditions above.
\end{theorem}

\begin{proof}
Apply preconditions into the definitions of allocation and deallocation, then the certain result of executions can be calculated according to the branches in the functions. The variables that change can be traced through state changes.
\end{proof}

To guarantee that the algorithm pocks out the most suitable block, two properties have to be proved: 1. the correctness of the mapping from the request memory block size to the level of the quad-tree. 2. the correctness of the quad-tree structure. Next are these two properties.

\begin{definition} {Mapping Request Sizes $\&$ Allocation Levels} \\
output\_level blo\_list rsize $\equiv$ THE l. l $<$ L blo\_list $\wedge$ rsize $\le$ blo\_list ! l $\wedge$ \\
\phantom{x} \hspace{10pt} (L blo\_list $>$ 1 $\wedge$ l $<$ L blo\_list - 1) $\longrightarrow$ rsize $>$ L blo\_list ! (l+1)
\end{definition}

Static linked list \textsl{blo\_list} is used to store the size of block for each level in a quad-tree. And \textsl{blo\_list} is a strictly decreasing list. Function \textsl{L} is used to get the length of a list. As mentioned above, the smaller the level, the larger size the memory block. The most suitable block means that its size has to be greater than or equal to the size of request block, and there is no smaller block that meets this condition. Through this definition, the most suitable block is picked up from \textsl{blo\_list}, and then mapped to the correct level of the quad-tree. Some lemmas ensure the correctness of this definition.

\begin{lemma}
L blo\_list $>$ 0 $\wedge$ rsize $\leq$ blo\_list ! (L blo\_list - 1) $\longrightarrow$ output\_level blo\_list rsize = L blo\_list - 1
\end{lemma}

\begin{lemma}
L blo\_list $>$ 1 $\wedge$ l $<$ L blo\_list - 1 $\wedge$ rsize $\leq$ blo\_list ! l $\wedge$ rsize $>$ blo\_list ! (l + 1) $\longrightarrow$ output\_level blo\_list rsize = l
\end{lemma}

\begin{proof}
To prove these two lemmas, the existence of such a level should be prove firstly by the predicates of rsize. Then with the assistance of the strictly decreasing blo\_list, the exact level can be located.
\end{proof}

Next, we introduce a lemma alone to prove the correctness of a quad-tree structure from the aspect of its level. The below \textbf{root} checks whether the tree is a root tree and \textbf{child} gives us all immediate child nodes.

\begin{lemma}
(root btree $\longrightarrow$ get\_level btree = 0) $\wedge$ (get\_level btree = l $\wedge$ l $\geq$ 0 $\wedge$ $\forall$chtree $\in$ child btree $\longrightarrow$ get\_level chtree = l + 1)
\end{lemma}

\begin{proof}
Induction can prove this because of the recursive structure of the quad-tree.
\end{proof}

With the correctness of the mapping operation and the structure of a quad-tree, we have the following theorem.

\begin{theorem}
The buddy allocation specification picks out the most suitable memory block and operates on the correct level in the quad-tree.
\end{theorem}

To avoid the fragmentation, merging operation is asked in the progress of deallocation. The following property is put forward to ensure the merging operation being correctly executed. The below \textbf{leaf} is to check whether the tree is a leaf.

\begin{definition} {Four Free Leaves Belong to The Same Node} \\
is\_FFL btree $\equiv$ $\forall$chtree $\in$ child btree. leaf chtree $\wedge$ State chtree = FREE
\end{definition}

Fig. \ref{fig2} can explain this definition well. Just like the subtree in the lower left corner of the first picture, four child nodes are all leaves and their states are \textsl{FREE}. Therefore, merging operation is necessary during the progress of deallocation to handle this situation. The following are the lemmas that ensure the non-existence of such \textsl{FFL} trees after allocation and deallocation operations if non-existence of such trees in preconditions.

\begin{lemma}
$\forall$b $\in$ blo\_set. $\neg$ is\_FFL b $\longrightarrow$ $\forall$b $\in$ fst (alloc blo\_set rlv). $\neg$ is\_FFL b
\end{lemma}

\begin{lemma}
$\forall$b $\in$ blo\_set. $\neg$ is\_FFL b $\longrightarrow$ $\forall$b $\in$ fst (free blo\_set b). $\neg$ is\_FFL b
\end{lemma}

\begin{proof}
Due to the operations being conducted on the recursive structure of the quad-tree, induction can solve the proofs with the assistants of the execution branches.
\end{proof}

\begin{theorem}
The buddy allocation specification guarantees non-existence of the FFL trees among all quad-trees.
\end{theorem}

In the end, we prove two significant properties: memory isolation and non-leakage. The first one is to prove non-existence of the overlap in the address spaces. Isolation in address spaces makes sure domains' memory blocks are not maliciously overwritten. Memory leakage means that available memory blocks (including occupied and free blocks) are getting less and less. Then non-leakage protects the address spaces.

For the specification level, we provisionally use \textsl{ID} to present a contiguous addresses for a memory block. The mapping between a \textsl{ID} and a true range of address and the one-to-one uniqueness guarantee will be introduced in the future work. Therefore, in this specification isolation in address spaces means that all \textsl{IDs} that leaves bring are different. The strategy of creating a new leaf has been already introduced in the previous subsection.

\begin{definition} {Different IDs} \\
is\_different blo\_set $\equiv$ $\forall$b $\in$ blo\_set. $\forall$l $\in$ tree.set b. ($\nexists$l'. l' $\in$ tree.set (SOME b. b $\in$ blo\_set) $\wedge$ l' $\ne$ l $\wedge$ ID l' = ID l)
\end{definition}

\begin{lemma}
is\_different blo\_set $\longrightarrow$ is\_different fst (alloc blo\_set rlv)
\end{lemma}

\begin{lemma}
is\_different blo\_set $\longrightarrow$ is\_different fst (free blo\_set b)
\end{lemma}

\begin{proof}
Induction proving can solve these lemmas with the assistants of the execution branches, because the operations are conducted on the recursive structure of the quad-tree.
\end{proof}

\begin{theorem}
The buddy allocation specification ensures all IDs of leaves are different.
\end{theorem}

For the memory non-leakage, because we use the quad-tree structure and map all the memory blocks into the leaves of the tree, it becomes easy to prove the property. Firstly, we have this understanding to a quad-tree: all the leaves (including occupied and free leaves) are in use. Thus once the certain relationship between the number of nodes and leaves has been proved, we can infer that the quad-tree always maintains correct structure. Hence,  we can prove that all the leaves are in use and none leaf is forgotten.

The first step is to prove the relationship between the number of nodes and leaves in a quad-tree.

\begin{lemma}
q-tree b: Num (Leaf b) = Num (Node b) $\times$ 3 + 1
\end{lemma}

\begin{proof}
We use induction  to prove this lemma because of the recursive structure of the quad-tree.
\end{proof}

\begin{lemma}
$\forall$b $\in$ blo\_set. q-tree b $\longrightarrow$ $\forall$b $\in$ fst (alloc blo\_set rlv). q-tree b
\end{lemma}

\begin{lemma}
$\forall$b $\in$ blo\_set. q-tree b $\longrightarrow$ $\forall$b $\in$ fst (free blo\_set b). q-tree b
\end{lemma}

\begin{proof}
Due to the operations being conducted on the recursive structure of the quad-tree, induction can solve the proofs with the assistants of the execution branches.
\end{proof}

\begin{theorem}
The buddy allocation specification guarantees any tree is a q-tree.
\end{theorem}

To sum up, in this section we introduce the quad-tree structure to simulate memory because of the buddy allocation algorithms. Then we give a specification for the algorithms including \textbf{alloc} and \textbf{free} operations. After that, we give proofs for functional correctness including preconditions and postconditions, the most suitable memory block, non-existence of the \textsl{FFL} trees, memory isolation and non-leakage. Through these efforts, we give a functionally correct buddy memory model.


\section{Model Memory Security}
The concept of noninterference is introduced in~\cite{reg_noninterference} to provide a formalism for the specification fo security policies. The main idea is that domain \textsl{u} is non-interfering with domain \textsl{v} if no action performed by \textsl{u} can influence the subsequence outputs seen by \textsl{v}.

\subsection{Memory Execution Model}
Considering the fact that the execution of the buddy memory allocation is expressed as a series of operating actions among initialization, allocation, release, scheduler and time-ticking in a serial system, we introduce an event framework to simulate the whole processing of the entire system. Another factor of introducing this framework is that we can verify whether the states before and after an execution both satisfy a certain property of correctness or security.

As we define, \textsl{State} is the basic element of the execution trace. The execution of each operation must follow a certain order, therefore the trace is defined as a \textsl{list} of type \textsl{State}. A trace is defined looks like this:

\phantom{x} \textbf{type\_synonym} \textsl{Trace} = "\textsl{State list}" \\

Different orders of execution of operations compose different execution pathways. For modeling all the possible pathways, we introduces a collection for all execution pathways in a inductive way.

\phantom{x} \textbf{inductive\_set} \textsl{execution} :: "\textsl{Trace set}" \textsl{where} \\
\phantom{x} \hspace{3pt} \textsl{zero\_exe}: "$\lbrack$\textsl{s}$\rbrack$ $\in$ \textsl{execution}" $\mid$ \\
\phantom{x} \hspace{3pt} \textsl{init\_exe}: "$\lbrack$\textsl{es} $\in$ \textsl{execution}; \textsl{fst} (\textsl{k\_mem\_pool\_define s nam nlv num}) = \textsl{t}; \textsl{t} = \textsl{es} ! \textsl{0}$\rbrack$ $\Longrightarrow$ \textsl{s} \# \textsl{es} $\in$ \textsl{execution}" $\mid$ \\
\phantom{x} \hspace{3pt} \textsl{alloc\_exe}: "$\lbrack$\textsl{es} $\in$ \textsl{execution}; \textsl{po} $\in$ \textsl{set} (\textsl{pools s}); \textsl{fst} (\textsl{k\_mem\_pool\_alloc s po lv ti}) = \textsl{t}; \textsl{t} = \textsl{es} ! \textsl{0}$\rbrack$ $\Longrightarrow$ \textsl{s} \# \textsl{es} $\in$ \textsl{execution}" $\mid$ \\
\phantom{x} \hspace{3pt} \textsl{free\_exe}: "$\lbrack$\textsl{es} $\in$ \textsl{execution}; \textsl{po} $\in$ \textsl{set} (\textsl{pools s}); \textsl{fst} (\textsl{k\_mem\_pool\_free s po num}) = \textsl{t}; \textsl{t} = \textsl{es} ! \textsl{0}$\rbrack$ $\Longrightarrow$ \textsl{s} \# \textsl{es} $\in$ \textsl{execution}" $\mid$ \\
\phantom{x} \hspace{3pt} \textsl{tick\_exe}: "$\lbrack$\textsl{es} $\in$ \textsl{execution}; \textsl{time\_tick s} = \textsl{t}; \textsl{t} = \textsl{es} ! \textsl{0}$\rbrack$ $\Longrightarrow$ \textsl{s} \# \textsl{es} $\in$ \textsl{execution}" $\mid$ \\
\phantom{x} \hspace{3pt} \textsl{schedule\_exe}: "$\lbrack$\textsl{es} $\in$ \textsl{execution}; \textsl{schedule s} = \textsl{t}; \textsl{t} = \textsl{es} ! \textsl{0}$\rbrack$ $\Longrightarrow$ \textsl{s} \# \textsl{es} $\in$ \textsl{execution}" \\

Firstly, the trace list which has only one state belongs to the execution pathways. Secondly, five operations on trace list have same pattern. Taking initialization function as an example. The \textsl{es} is one execution pathway of type \textsl{list} and initialization function translates the previous state \textsl{s} into state \textsl{t}. If the state \textsl{t} is the first element of list \textsl{es}, then we can add state \textsl{s} to the head of execution pathway \textsl{ex} to form a new list (\textsl{s} \# \textsl{es}). Eventually, the new list (\textsl{s} \# \textsl{es}) is also one execution pathway.

Thereafter, we have to define a reachable set using the execution trace. The purpose of introducing reachable set whose execution trace starts from \textsl{s0} is to prove all properties are established on reachable set. Following is the definition of reachable set.

\phantom{x} \textbf{definition} "\textsl{reachable s t} $\equiv$ ($\exists$\textsl{s} $\in$ \textsl{execution}. \textsl{ts} ! \textsl{0} = \textsl{s} $\wedge$ \textsl{last ts} = \textsl{t})" \\
\phantom{x} \hspace{3pt} \textbf{definition} "\textsl{reachable0 s} $\equiv$ \textsl{reachable s0 s}" \\
\phantom{x} \hspace{3pt} \textbf{definition} "\textsl{ReachStates} $\equiv$ $\lbrace$\textsl{s}. \textsl{reachable0 s}$\rbrace$"

But how to connect the allocation operation and releasing operation? The answer is the scheduling. According to the C-code level in Zepyhr OS, two places need the participation of scheduling: (1).Once the memory allocation process fails and one of the thread's parameters indicates that it will wait, we need to add the thread to the corresponding memory pool's waiting queue and then schedule another thread to run. (2).Each time after the releasing operation, the algorithm checks if there are any threads in the waiting queue of the memory pool. If there are, it wakes up all threads and scheduler arranges for one thread to execute. Although scheduling operation is not the primary role in memory algorithm verification, for algorithmic integrity, we introduce an abstract scheduling which takes any thread from the ready queue to our buddy memory model.


\subsection{Security Proofs}


\section{Conclusions and Future Work}
To sum up, we give a specification for buddy memory allocation algorithm. 

\begin{thebibliography}{8}
\bibitem{reg_Isabelle/HOL}
T. Nipkow, L. C. Paulson, and M. Wenzel. Isabelle/HOL-A Proof Assistant for Higher-Order Logical, volume 2283 of LNCS. Springer-Verlag, 2002.

\bibitem{reg_noninterference}
J. Goguen and J. Meseguer. Security Policies and Security Models, Proceedings of the IEEE Computer Society Symposium on Research in Security and Privacy, 1982, p. 11-20.


\end{thebibliography}


\end{document}